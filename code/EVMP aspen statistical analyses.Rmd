---
title: "EVMP Aspen Statistical Analyses"
author: ""
date: ""
output: 
  html_document: 
    theme: journal
    toc: yes
    toc_depth: 4
---

```{r setup, include=FALSE}
library(knitr)
opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, fig.align = 'center')
opts_knit$set(root.dir=normalizePath('../')) # this is required if Rmd is nested below the project directory
opts_chunk$set(fig.path = "../output/figures/") # corrected path and added dev. Needed to specify a subdirectory for figs

set.seed(1234)
```

```{r, echo=FALSE, warning=FALSE, message=FALSE, comment=FALSE, eval=TRUE}
suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(fs))
suppressPackageStartupMessages(library(sf))
suppressPackageStartupMessages(library(janitor))
suppressPackageStartupMessages(library(readxl))
suppressPackageStartupMessages(library(mapview))
suppressPackageStartupMessages(library(viridis))
suppressPackageStartupMessages(library(ggstance))
suppressPackageStartupMessages(library(readxl))
suppressPackageStartupMessages(library(DT))
suppressPackageStartupMessages(library(lubridate))
suppressPackageStartupMessages(library(skimr)) 
suppressPackageStartupMessages(library(dataMaid))
library(lubridate)
library(emmeans)
library(rstanarm)
options(mc.cores = parallel::detectCores())
library(bayestestR)
library(gt)

```


```{r, functions, echo=FALSE, warning=FALSE, message=FALSE, comment=FALSE, eval=TRUE}
### Table functions
## function to describe model output
fun.desc.post1 <- function(model){
  describe_posterior(
  model,
  effects = "fixed",
  component = "all",
  ci_method = "hdi",
  ci=0.9,
  test = c("p_direction", "p_significance"),
  centrality = "all"
) %>% 
    as_tibble() %>% 
    DT::datatable(caption = "Posterior description")
}

## gt
fun.desc.post1.gt <- function(model){
  describe_posterior(
  model,
  effects = "fixed",
  component = "all",
  ci_method = "hdi",
  ci=0.9,
  test = c("rope"),
  #rope_range(c(-0.1,0.1)),
  rope_range("default"),
  rope_ci=0.9,
  centrality = "median"
) %>% 
    as_tibble() %>% 
    gt() %>% 
    tab_header(title = "Posterior description") %>% 
    fmt_number(
    columns = 2:12,
    decimals = 1,
    suffixing = TRUE
  )
}

# describe posterior
fun.desc.post1.gt.rope <- function(model){
  describe_posterior(
  model,
  effects = "fixed",
  component = "all",
  ci_method = "hdi",
  ci=0.9,
  test = c("p_direction", "p_significance","rope"),
  #rope_range(c(-0.1,0.1)),
  rope_range("default"),
  rope_ci = 0.9,
  centrality = "median"
) %>% 
    as_tibble() %>% 
    gt() %>% 
    tab_header(title = "Posterior description") %>% 
    fmt_number(
    columns = 2:14,
    decimals = 2,
    suffixing = TRUE
  )
}

#### Plotting functions
fun.contrast.plot <- function(df){
  df %>% 
  ggplot(aes(x = contrast)) +
  geom_linerange(aes(ymin = lower.HPD, ymax = upper.HPD), color = "lightblue", size = 2) +
  geom_point(aes(y = estimate), size = 2.5) +
  theme_minimal() +
  labs(caption = "Point estimate displayed: median 
HPD interval probability: 0.95", x = "Estimate", y = "Estimate") +
  coord_flip()
}

## ppcheck.plot
ppc.plot <- function(model){
  pp_check(model) +
  labs(x = "Value", y = "Density") +
  theme_minimal()
}

## describe posterior to DT
desc.post1 <- function(model){
  describe_posterior(
  model,
  effects = "all",
  component = "all",
  test = c("p_direction", "p_significance"),
  centrality = "all"
) %>% 
    as_tibble() %>% 
    DT::datatable(caption = "Posterior description")
}

```

# Introduction

This document contains code for running statistical analyses of of Elk
Vegetation Management Plan (EVMP) data collected through the 2018
sampling season. Analyses are limited to data from plots
established in aspen communities in areas of the elk winter range (core and noncore areas) and
the Kawuneeche Valley (i.e., "aspen" plots, see Zeigenfuss et al. 2011) and is provided as a supplement to the NPS NRR Report
"Monitoring of Vegetation Response to Elk Population and Habitat
Management in Rocky Mountain National Park - Analysis of Elk Vegetation
Management Plan monitoring Data: 2008--2018". For information on
sampling and the broader analysis and interpretation of the results,
refer to this report, past analyses [@zeigenfuss2015], and the original
EVMP monitoring plan [@zeigenfuss2011].

# Methods

The code and results presented here start from and build upon derived
data produced in a separate code document focused on ingesting,
compiling, and cleaning raw data provided by RMNP staff. Extensive
"munging" of raw files was required, so the decision was made to
separate code used to pre-process raw data from code used for the
analyses presented here. Likewise, separate code documents were
developed for other distinct elements of the larger EVMP (e.g., willow
and upland plots).

Bayesian repeated measures analyses were fit separately for combined
core and non-core winter range, core winter range (WC) and non-core
winter range plots (WNC) with plots treated as random factors using the ‘stan_glmer’ function in the rstanrm package [@goodrich2020][@brilleman2018]. Bayesian estimation was performed via MCMC adding independent weakly informed priors specific to the data type being modeled for regression coefficients  Lemoine (2019) for difference response variable types (e.g., willow height, aspen suckering density). Continuous response variables (e.g., willow height) were fit with a Gamma distribution, which restricts possible responses to positive real numbers. Count data like aspen stem counts were modeled as poisson processes, while proportion data (e.g., cover) were modeled using a beta distribution (Ferrari and Cribari-Neto 2004) that constrains values from 0 to 1.

# fu 
For willow height, models were fit using
weekly informative priors and a gamma distribution with the "stan_lmer"
function in the "rstanarm" package [@goodrich2020][@brilleman2018].

For continuous proportions such as plant cover (i.e, those not derived
from count data), a common approach to modeling is to transform data
then use ordinary linear models, however this creates problems for
interpretation and inference [@douma2019]. Techniques relying on
transformations make estimates on the transformed scale, requiring
back‐transformation for reporting and interpretation. However, the
relationship between the original and transformed proportions is often
non‐linear, creating issues for interpretation [@douma2019]. Alternative
approaches using beta regression [@cribari-neto2009][@ferrari2004] have
been developed and are relied on here for modeling continuous
proportions (e.g., willow cover). After fitting appropriate models using
"rstanarm" functions, comparisons of estimated marginal means were made
between time classes and management classes (e.g., fencing) using
functions in the "emm" R package [@lenth2020].


```{r}
## read in data

# Aspen ht
ht_perc1 <- read_csv("./output/exported_data/asp_ht_perc1_20200309.csv")
ht_perc1 %>% 
  glimpse()

ht_perc1 %>% 
  visdat::vis_dat()

```

```{r}
# Data munging

## filter out in-between years
ht_perc1 <- ht_perc1 %>%
  filter(timeClass %in% c("BL","2013", "2018")) 

### factor relevel
ht_perc1 <- ht_perc1 %>% 
  mutate(timeClass = as.factor(timeClass)) %>% 
  mutate(timeClass = fct_relevel(timeClass, "BL", "2013", "2018")) %>% 
  mutate(RANGE_TYPE = as.factor(RANGE_TYPE)) %>% 
  mutate(RANGE_TYPE = fct_relevel(RANGE_TYPE, "core winter range","non-core winter range","Kawuneeche Valley"))   

```

```{r}
ht_perc1 <- ht_perc1 %>% 
  clean_names()

## set factor levels for burned and fenced
ht_perc1 <- ht_perc1 %>%
  mutate(fenced.long = case_when(fenced == "N" ~ "Unfenced",
                                 fenced == "Y" ~ "Fenced",
                                 TRUE ~ fenced)) %>% 
  mutate(burned = case_when(burned == "Not burned" ~ "Unburned",
                            TRUE ~ burned)) %>%
  mutate(fenced.long = as_factor(fenced.long)) %>%
  mutate(burned = as_factor(burned))

ht_perc1 %>% 
  distinct(site_type)
  
asp.ac <- ht_perc1 %>% 
  filter(site_type == "AC") 

# non core
asp.anc <- ht_perc1 %>% 
  filter(site_type == "ANC")

asp.akv <- ht_perc1 %>% 
  filter(site_type == "AK")

```


# Results


```{r, eval=FALSE}
### Traditional AOV
aov_model_asp_htperc <- aov(stemDen.ha ~ RANGE_TYPE*timeClass + Error(SITE_ID/(RANGE_TYPE*timeClass)), data = ht_perc1)

aov_model_asp_htperc <- aov(stemDen.ha ~ RANGE_TYPE*timeClass + Error(1/SITE_ID), data = ht_perc1)

```


## Bayesian Analyses

### AC - Aspen stem count

#### main factors only

```{r}
## adding a tiny number to conform with gamma
asp.ac <- asp.ac %>%
  mutate(stem_den_ha = stem_den_ha +0.0000001)


## poisson
stmod_stally1 <- stan_glmer(stem_tally ~ time_class + fenced + (1 | site_id), data = asp.ac,
                       family=poisson,
                      iter = 10000,
                      seed = 1234
                      )

prior_summary(stmod_stally1)
pp_check(stmod_stally1)
```

#### main factors + interactions

```{r}
## run with gamma
stmod_stally2 <- stan_glmer(stem_tally ~ time_class * fenced + (1 | site_id), data = asp.ac,
                      family= poisson,
                      iter = 10000,
                      seed = 1234
                      )

summary(stmod_stally2)
prior_summary(stmod_stally2)

pp.stally2.wc <- pp_check(stmod_stally2)
pp.stally2.wc +
  labs(x = "Value", y = "Density") +
  theme_minimal()

```

```{r, eval = FALSE}
# install.packages("shinystan")
library("shinystan")
## shiny eval
launch_shinystan(stmod_stally2)

```

#### Model comparison

Compares model with and without interactions for AC plots
```{r, eval = FALSE}
## model comparison
loo1 <- loo(stmod_stally1,
            k_threshold = 0.7) # Found 3 observation(s) with a pareto_k > 0.7. We recommend calling 'loo' again with argument 'k_threshold = 0.7' in order to calculate the ELPD without the assumption that these observations are negligible. This will refit the model 3 times to compute the ELPDs for the problematic observations directly.

loo2 <- loo(stmod_stally2,
            k_threshold = 0.7) 
comp <- loo_compare(loo2, loo1)

## create table of comparisons
modcomp_ac <- print(comp, simplify = TRUE, digits = 2)

modcomp_ac %>% 
  gt()
# citation(package = "loo")



# show more details with simplify=FALSE
# (will be the same for all models in this artificial example)
print(comp, simplify = FALSE, digits = 3)
```

```{r, eval = FALSE}
## report
# report::report(stmod_stally2)
```

```{r, eval = FALSE}
# note the function in the next chunk is good
describe_posterior(
  stmod_ht1,
  effects = "all",
  component = "all",
  test = c("p_direction", "p_significance"),
  centrality = "all"
)
# Posterior: point estimates
centrality <- point_estimate(stmod_ht1)  # Get indices of centrality
centrality
```

```{r}
### model checks
# Compare the model with default weak priors and the one with the null
#pp_check(stmod_ht2)

ppc.plot(stmod_stally2)
# ggsave("./output/figures_exported/ac_stemtally_ppc1.png", dpi = 300, width = 4.75, height = 3.75)
# pp_check(stmod_ht2)
# pp_check(stmod_ht1_noPrior)


```



```{r}
### Model posterior parameters to table
fun.desc.post1.gt.rope(stmod_stally2) %>% 
  tab_header(title = "stan_glmer(stem_tally ~ time_class * fenced + (1 | site_id), data = asp.ac)")

# fun.desc.post1.gt.rope(stmod_stally2) %>% 
#   gt::gtsave(filename = "./output/tables/ac_stemcnt_stmod2_posteriors.rtf")


```

get posteriors

```{r}
posteriors.ac.stcnt <- insight::get_parameters(stmod_stally2)

posteriors.ac.stcnt %>% 
  glimpse()

# tidy the posteriors
posteriors.ac.stcnt.tidy <- posteriors.ac.stcnt %>%
  # names()
  pivot_longer(cols = starts_with("time"), names_to = "variable", values_to = "values")

```

```{r}
library(ggridges)

posteriors.ac.stcnt.tidy %>% 
  ggplot() +
  ggridges::geom_density_ridges(aes(x = values, y = variable))

posteriors.ac.stcnt.tidy %>% 
  ggplot() +
  geom_density(aes(fill = variable, x = values, color = variable), alpha = .12) +
  theme_minimal()

```


```{r}
#### PD - AC

pd.ac <- p_direction(stmod_stally2)
p.in.rope.ac <- rope(stmod_stally2, ci=1)

pd.tab.ac <- p.in.rope.ac %>% 
  gt() %>%
  tab_header(title = "Percent in ROPE") %>% 
  fmt_number(
    columns = 5,
    decimals = 1,
    suffixing = TRUE
  ) 
pd.tab.ac %>% 
# pd.tab.wcc %>% 
  gt::gtsave(filename = "./output/tables/ac_stemcnt_percent_in_ROPE.rtf")

# Visualise the pd
ac.stmcnt.pd <- plot(pd.ac)
ac.stmcnt.pd +
  theme_minimal() +
  labs(caption = "Aspen stem count, core winter range")
# ggsave("./output/figures_exported/pd_ac_stemcnt.png", dpi = 300, width = 6.75, height =3.75)
```


```{r}
#### Contrasts - WC time class
# EMMs for later factor levels are subtracted from those for earlier levels; if you want the comparisons to go in the other direction, use pairs(pigs.emm.s, reverse = TRUE).

# library(emmeans)
ac.emm.stcnt <- emmeans(stmod_stally2, ~ time_class)

ac.pairs.timeClass <- pairs(ac.emm.stcnt, reverse = TRUE)

# pairs.timeClass <- pairs(emmeans(stmod_ht2, ~ time_class)) # more compact way to do above

gg.emm.ac.stcnt <- plot(ac.pairs.timeClass) +
  theme_minimal() +
  labs(subtitle = "Point estimate displayed: median 
HPD interval probability: 0.95", x = "Estimate", y = "Contrast", caption = "Core Winter Range, Aspen Stem Count")

gg.emm.ac.stcnt
# ggsave("./output/figures_exported/gg_emm_ac_stcnt.png", width = 4.5, height = 3.55, dpi=300)


# pairs.timeClass.exp %>% 
#   ggplot(aes(x = contrast)) +
#   geom_point(aes(y = estimate)) +
#   geom_linerange(aes(ymin = lower.HPD, ymax = upper.HPD)) +
#   theme_minimal() +
#   labs(title = "Point estimate displayed: median 
# HPD interval probability: 0.95")

```

```{r}
# library(emmeans)
ac.emm.stcnt.fen <- emmeans(stmod_stally2, ~ fenced)

ac.pairs.fenced <- pairs(ac.emm.stcnt.fen, reverse = TRUE)

gg.emm.ac.stcnt.fenced <- plot(ac.pairs.fenced) +
  theme_minimal() +
  labs(subtitle = "Point estimate displayed: median 
HPD interval probability: 0.95", x = "Estimate", y = "Contrast", caption = "Core Winter Range, Aspen Stem Count")

# gg.emm.ac.stcnt.fenced

```


```{r, eval = FALSE}

ac.emm.stcnt.fenxTC <- emmeans(stmod_stally2, ~time_class * fenced)

pairs.timeClassxfenced.ac <- pairs(ac.emm.stcnt.fenxTC, by = "fenced", reverse = TRUE) # simple effects for color

plot(pairs.timeClassxfenced.ac) +
  theme_minimal() +
  # labs(x = "Median estimate", y = "", caption = "pairs.timeClassxRange") +
  labs(subtitle = "Point estimate displayed: median 
HPD interval probability: 0.95", x = "Median estimate", y = "Contrast", caption = "Core Winter Range, Aspen stem count")

# ggsave("./output/figures_exported/gg_emm_ac_ht_TC_Fenced.png", width = 4.5, height = 3.55, dpi=300)
```

#### AC - Burned

```{r}
ht_perc1_summary <- ht_perc1 %>%
  group_by(time_class, range_type, burned, fenced.long) %>% 
  summarytools::descr(stats = "fivenum") %>% 
  summarytools::tb()

ht_perc1 %>% 
  filter(range_type == "core winter range") %>% 
  filter(time_class == "BL" | time_class == "2013" | time_class == "2018") %>%
  group_by(time_class, range_type, burned, fenced.long) %>% 
  # summarytools::descr(stats = "fivenum") %>% 
  summarytools::descr() %>%
  summarytools::tb() %>% 
  datatable(filter = "top")

```

```{r}
ht_perc1 %>% 
  filter(range_type == "core winter range") %>% 
  filter(time_class == "BL" | time_class == "2013" | time_class == "2018") %>% 
  ggplot(aes(burned, log(stem_tally))) +
  # ggplot(aes(burned, stem_tally)) +
  geom_boxplot(aes(fill = time_class)) +
  facet_wrap(~fenced.long) +
  ylim(0, 5)

```


```{r}
### STAN model
stmod_ac_burned_stally1 <- stan_glmer(stem_tally ~ fenced.long * time_class * burned + (1 | site_id), data = asp.ac,
                       family=poisson,
                      iter = 10000,
                      seed = 1234
                      )

prior_summary(stmod_ac_burned_stally1)
pp_check(stmod_ac_burned_stally1)

```

```{r}
pd.ac.burned <- p_direction(stmod_ac_burned_stally1)
p.in.rope.ac.burned <- rope(stmod_ac_burned_stally1, ci=1)

pd.tab.ac.burned <- p.in.rope.ac.burned %>% 
  gt() %>%
  tab_header(title = "Percent in ROPE") %>% 
  fmt_number(
    columns = 5,
    decimals = 1,
    suffixing = TRUE
  ) 
pd.tab.ac.burned %>% 
# pd.tab.wcc %>% 
  gt::gtsave(filename = "./output/tables/ac_stemcnt_burned_TC_percent_in_ROPE.rtf")

# Visualise the pd
ac.stmcnt.pd.burned <- plot(pd.ac.burned)
ac.stmcnt.pd.burned +
  theme_minimal() +
  labs(caption = "Aspen stem count, core winter range")

# ggsave("./output/figures_exported/pd_ac_stemcnt_burned_fenced.png", dpi = 300, width = 6.75, height =5.75)
# ggsave("./output/figures_exported/pd_ac_stemcnt_burned_fenced.pdf", width = 6.75, height =5.75)
```

```{r}
## contrasts
# library(emmeans)

ac.burned.emmgrid <- emmeans::ref_grid(stmod_ac_burned_stally1)

ac.emm.stcnt.burned <- emmeans(stmod_ac_burned_stally1, ~ burned)

plot(ac.emm.stcnt.burned)

ac.pairs.burned <- pairs(ac.emm.stcnt.burned, reverse = TRUE)

ac.burned.emmgrid.pairs <- 
  pairs(ac.burned.emmgrid, reverse = TRUE)

# type - response
plot(ac.burned.emmgrid, by = "burned",type = "response")
# type - linear predictor
plot(ac.burned.emmgrid, by = "burned", type = "linear.predictor") + 
  theme_minimal()


# plot(ac.burned.emmgrid, by = "fenced.long")

gg.emm.ac.stcnt.burned <- plot(ac.burned.emmgrid, by = "time_class") +
  theme_minimal() +
labs(subtitle = "Point estimate displayed: median 
HPD interval probability: 0.95", x = "Estimate", y = "Contrast", caption = "Core Winter Range, Aspen Stem Count - Burned")

gg.emm.ac.stcnt.burned
# ggsave("./output/figures_exported/gg_emm_ac_stcnt_burned.png", width = 4.5, height = 5.55, dpi=300)
# ggsave("./output/figures_exported/gg_emm_ac_stcnt_burned.pdf", width = 4.5, height = 5.55)

```


----

### ANC - Aspen stem count

#### Main factors + interactions

```{r}
stmod_anc_stally1 <- stan_glmer(stem_tally ~ time_class * fenced + (1 | site_id), data = asp.ac,
                       family=poisson,
                      iter = 10000,
                      seed = 1234
                      )

prior_summary(stmod_anc_stally1)
pp_check(stmod_anc_stally1)

```




```{r}
# get posteriors
posteriors.anc.stmcnt <- insight::get_parameters(stmod_anc_stally1)

posteriors.anc.stmcnt %>% 
  glimpse()


```


```{r}
#### PP check plot
ppc.plot(stmod_anc_stally1)
# ggsave("./output/figures_exported/anc_stmcnt.png", dpi = 300, width = 4.75, height = 3.75)
```


#### Model posterior parameters to table
```{r, eval = FALSE}

## View
fun.desc.post1.gt.rope(stmod_anc_stally1)


## save
fun.desc.post1.gt.rope(stmod_anc_stally1) %>% 
  gt::gtsave(filename = "./output/tables/stmod_anc_stally1.rtf")


```


```{r, eval = FALSE}
# install.packages("shinystan")
library("shinystan")
## shiny eval
launch_shinystan(stmod_anc_stally1)
```

#### PD - ANC
```{r}
pd.anc <- p_direction(stmod_anc_stally1)
p.in.rope.anc <- rope(stmod_anc_stally1, ci=1)

pd.tab.anc <- p.in.rope.anc %>% 
  gt() %>%
  tab_header(title = "Percent in ROPE") %>% 
  fmt_number(
    columns = 5,
    decimals = 1,
    suffixing = TRUE
  ) 
pd.tab.anc
# pd.tab.wnc %>% 
#   gt::gtsave(filename = "./output/tables/wnc_wh_percent_in_ROPE.rtf")

# Visualise the pd
anc.stmcnt.pd <- plot(pd.anc)
anc.stmcnt.pd +
  theme_minimal() +
  labs(caption = "Aspe stem count, non-core winter range")
# ggsave("./output/figures_exported/pd_anc_stemcntb.png", dpi = 300, width = 6.75, height =3.75)
```

#### Contrasts - time class
```{r}
# library(emmeans)
anc.emm <- emmeans(stmod_anc_stally1, ~ time_class,)

anc.pairs.timeClass <- pairs(anc.emm)

gg.emm.anc.stmcnt <- plot(anc.pairs.timeClass) +
  theme_minimal() +
  labs(subtitle = "Point estimate displayed: median 
HPD interval probability: 0.95", x = "Estimate", y = "Contrast", caption = "Non-core Winter Range, Aspen stem counts")

gg.emm.anc.stmcnt
# ggsave("./output/figures_exported/gg_emm_anc_stmcnt_TConly.png", width = 4.5, height = 3.55, dpi=300)

```

#### Contrasts - Fenced * time class
```{r}
# library(emmeans)
anc.emm.tcxf <- emmeans(stmod_anc_stally1, ~ time_class*fenced)

anc.pairs.tcxf <- pairs(anc.emm.tcxf, by = "fenced", reverse = TRUE)

gg.emm.anc.stmcnt.tcxf <- plot(anc.pairs.tcxf) +
  theme_minimal() +
  labs(subtitle = "Point estimate displayed: median 
HPD interval probability: 0.95", x = "Estimate", y = "Contrast", caption = "Non-core Winter Range, Aspen stem counts")

gg.emm.anc.stmcnt.tcxf
# ggsave("./output/figures_exported/gg_emm_anc_stmcnt_tcxf.png", width = 4.5, height = 3.55, dpi=300)

```


## AK - Aspen stem count

### Model spec
```{r}
# asp.akv %>% visdat::vis_dat()

kv.stmod_stmcnt1 <- stan_glmer(stem_tally ~ time_class + (1 | site_id), data = asp.akv,
                       family=poisson,
                      iter = 10000,
                      seed = 1234,
                      control = list(adapt_delta = 0.99))

# There were 2 divergent transitions after warmup. Increasing adapt_delta to 0.99
# see: https://mc-stan.org/misc/warnings.html#divergent-transitions-after-warmup

# pairs(kv.stmod_stmcnt1)

prior_summary(kv.stmod_stmcnt1)
# pp_check(kv.stmod_stmcnt1)
```

#### PP check plot
```{r}
ppc.plot(kv.stmod_stmcnt1)
# ggsave("./output/figures_exported/ak_stemct_ppc1.png", dpi = 300, width = 4.75, height = 3.75)
```


#### Model posterior parameters to table
```{r, eval = FALSE}
## View
fun.desc.post1.gt.rope(kv.stmod_stmcnt1)


## save
# fun.desc.post1.gt.rope(kv.stmod_stmcnt1) %>% 
#   gt::gtsave(filename = "./output/tables/AK_kv.stmod_stmcnt1_posteriors.rtf")


```

#### PD - KV
```{r}
pdkv <- p_direction(kv.stmod_stmcnt1)
p.in.rope.kv <- rope(kv.stmod_stmcnt1, ci=1)

pd.tab.kv <- p.in.rope.kv %>% 
  gt() %>%
  tab_header(title = "Percent in ROPE") %>% 
  fmt_number(
    columns = 5,
    decimals = 1,
    suffixing = TRUE
  ) 
pd.tab.kv

## save table
# pd.tab.kv %>%
#   gt::gtsave(filename = "./output/tables/wnc_wh_percent_in_ROPE.rtf")

# Visualise the pd
kv.stmcnt.pd <- plot(pdkv)
kv.stmcnt.pd +
  theme_minimal() +
  labs(caption = "Willow height, KV")
# ggsave("./output/figures_exported/pd_kv_stmcnt.png", dpi = 300, width = 6.75, height =3.75)

```

#### Contrasts - KV tc
```{r}
# library(emmeans)
kv.emm <- emmeans(kv.stmod_stmcnt1, ~ time_class)

kv.pairs.fenced <- pairs(kv.emm, reverse = TRUE)

gg.emm.kv.stmcnt <- plot(kv.pairs.fenced) +
  theme_minimal() +
  labs(subtitle = "Point estimate displayed: median 
HPD interval probability: 0.95", x = "Estimate", y = "Contrast", caption = "KV, aspen stem count")

gg.emm.kv.stmcnt
# ggsave("./output/figures_exported/gg_emm_AK_stmcnt.png", width = 4.5, height = 3.55, dpi=300)

```


# Early iterations below



```{r, eval=FALSE}
# null prior
stan_model2 <- stan_lmer(stemDen.ha ~ timeClass*RANGE_TYPE + (1 | SITE_ID), data = ht_perc1,
                        prior = NULL)

pp_check(stan_model)
pp_check(stan_model2)
pp_check(stan_model_b)

posteriors <- insight::get_parameters(stan_model)
posteriors2 <- insight::get_parameters(stan_model2)
```

```{r, eval=FALSE}
posteriors.t1 <- posteriors %>%
  # names()
  pivot_longer(cols = starts_with("time"), names_to = "variable", values_to = "values")

library(ggridges)
posteriors.t1 %>% 
  ggplot() +
  ggridges::geom_density_ridges(aes(x = values, y = variable))

posteriors.t1 %>% 
  ggplot() +
  geom_density(aes(fill = variable, x = values, color = variable), alpha = .12) +
  theme_minimal()

library(emmeans)
pairs.timeClass <- pairs(emmeans(stan_model, ~ timeClass))
pairs.timeClass
plot(pairs.timeClass) +
  labs(title = "Aspen density")

pairs.range_type <- pairs(emmeans(stan_model, ~ RANGE_TYPE))
pairs.range_type
plot(pairs.range_type) +
  theme_minimal() +
  labs(x = "Median estimate", y = "", caption = "pairs.range_type")

pairs.timeClassxRange <- emmeans(stan_model, ~timeClass * RANGE_TYPE)
pairs(pairs.timeClassxRange, by = "timeClass") # simple effects for color
plot(pairs.timeClassxRange) +
  theme_minimal() +
  labs(x = "Median estimate", y = "", caption = "pairs.timeClassxRange") 


```


```{r, eval=FALSE}
# Compute HDI and ETI
ci_hdi <- ci(posteriors, method = "HDI")
ci_eti <- ci(posteriors, method = "ETI")

# Plot the distribution and add the limits of the two CIs
# posteriors %>% 
#   select(timeClass2:RANGE_TYPE2) %>% 
#   estimate_density(extend=TRUE) %>% 
#   ggplot(aes(x=x, y=y)) +
#   geom_area(fill="orange") +
#   theme_classic() +
#   # HDI in blue
#   geom_vline(xintercept=ci_hdi$CI_low, color="royalblue", size=3) +
#   geom_vline(xintercept=ci_hdi$CI_high, color="royalblue", size=3) +
#   # Quantile in red
#   geom_vline(xintercept=ci_eti$CI_low, color="red", size=1) +
#   geom_vline(xintercept=ci_eti$CI_high, color="red", size=1)

```

```{r, eval=FALSE}

pairs.timeClassxRange <- emmeans(stan_model, ~timeClass * RANGE_TYPE)
pairs(pairs.timeClassxRange, by = "timeClass") # simple effects for color
plot(pairs.timeClassxRange) +
  theme_minimal() +
  labs(x = "Median estimate", y = "", caption = "pairs.timeClassxRange") 


```



```{r, eval=FALSE}
#### stan_aov
# my_prior <- normal(location = c(-10, 0), scale = c(5, 2), autoscale = FALSE)
# stan_glm(y ~ x1 + x2, data = dat, prior = my_prior)

stav <- stan_aov(stemDen.ha ~ RANGE_TYPE*timeClass, data = ht_perc1, prior = NULL)


```



```{r, eval=FALSE}
# 
library(emmeans)
pairs.timeClass <- pairs(emmeans(stav, ~ timeClass))
pairs.timeClass

pairs.range_type <- pairs(emmeans(stav, ~ RANGE_TYPE))
pairs.range_type


plot(pairs.timeClass)
plot(pairs.range_type)

em.timeClassxRange <- emmeans(stav, ~timeClass * RANGE_TYPE)
pairs(em.timeClassxRange, by = "timeClass") # simple effects for color
plot(em.timeClassxRange)

# >EMMs for later factor levels are subtracted from those for earlier levels; if you want the comparisons to go in the other direction, use pairs(pigs.emm.s, reverse = TRUE). Also, in multi-factor situations, you may specify by factor(s) to perform the comparisons separately at the levels of those factors.

```

