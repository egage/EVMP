---
title: "Elk Vegetation Management Plan Analysis: Baseline-2018 Data"
author: ''
date: ''
output:
  html_document: 
    fig_caption: yes
    theme: yeti
    toc: yes
  word_document:
    toc: yes
    toc_depth: '1'
---

```{r setup, include=FALSE}
library(knitr)
opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE, fig.align = 'center')
opts_knit$set(root.dir=normalizePath('../')) # this is required if Rmd is nested below the project directory
opts_chunk$set(fig.path = "../output/figures/") # corrected path and added dev. Needed to specify a subdirectory for figs

# see discussion here: https://stackoverflow.com/questions/24585254/working-with-knitr-using-subdirectories

```


```{r,echo=FALSE}
# library(here)
# here()
# install.packages("bindrcpp")
suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(fs))
suppressPackageStartupMessages(library(sf))
# library(raster)
suppressPackageStartupMessages(library(janitor))
suppressPackageStartupMessages(library(readxl))
# library(glue)
suppressPackageStartupMessages(library(mapview))
# library(ggmap)
# library(ggrepel)
suppressPackageStartupMessages(library(viridis))
# library(ggExtra)
suppressPackageStartupMessages(library(ggstance))
suppressPackageStartupMessages(library(readxl))
suppressPackageStartupMessages(library(DT))
# library(kableExtra)
suppressPackageStartupMessages(library(lubridate))
suppressPackageStartupMessages(library(skimr)) 
suppressPackageStartupMessages(library(dataMaid))
# library(ggmap)
library(lubridate)
library(mapview)
library(vtree)
library(bayestestR)

# library(flextable) # using gt instead

library(gt)
library(rstatix)
# devtools::install_github("dkahle/ggmap")
library(ggmap)
library(gt)
library(summarytools)
library(ggrepel)
library(ggtext)

## vroom https://vroom.r-lib.org/articles/vroom.html
```

https://vroom.r-lib.org/articles/vroom.html


### Function definitions
```{r, utilityFuncDefn, echo=FALSE, warning=FALSE,message=FALSE, comment=FALSE}
# define some utility functions...
#--------------------
# SO: http://stackoverflow.com/questions/11610377/how-do-i-change-the-formatting-of-numbers-on-an-axis-with-ggplot
# ...gives proper 'x10(superscript)5' notation on the axes. 

fancy_scientific <- function(l) {
     # turn in to character string in scientific notation
     l <- format(l, scientific = TRUE)
     # quote the part before the exponent to keep all the digits
     l <- gsub("^(.*)e", "'\\1'e", l)
     # turn the 'e+' into plotmath format
     l <- gsub("e", "%*%10^", l)
     # return this as an expression
     parse(text=l)
}

# Which you can then use as

# ggplot(data=df, aes(x=x, y=y)) +
#    geom_point() +
#    scale_y_continuous(labels=fancy_scientific) 

## fun to add r2
# GET EQUATION AND R-SQUARED AS STRING
# SOURCE: http://goo.gl/K4yh

lm_eqn <- function(df){
    m <- lm(y ~ x, df);
    eq <- substitute(italic(y) == a + b %.% italic(x)*","~~italic(r)^2~"="~r2, 
         list(a = format(coef(m)[1], digits = 2), 
              b = format(coef(m)[2], digits = 2), 
             r2 = format(summary(m)$r.squared, digits = 3)))
    as.character(as.expression(eq));                 
}

# p1 <- p + geom_text(x = 25, y = 300, label = lm_eqn(df), parse = TRUE)



# ######### DEAL WITH NA #############
# na_strings <- c("NA", "N A", "N / A", "N/A", "N/ A", "Not Available", "NOt available")
# 
# baseline <- baseline %>%
#   naniar::replace_with_na_all(condition = ~.x %in% na_strings) %>%

```

```{r, echo=FALSE, warning=FALSE,message=FALSE, comment=FALSE, eval=TRUE}

# some themes
theme_smFacet <- theme_bw() + theme(strip.text.x = element_text(size = 7))
theme_smFacet2 <- theme_bw() + theme(strip.text.x = element_text(size = 6))
# theme_CowsMod1 <- theme_cowplot() + 
#   theme(strip.text.x = element_text(size = 7)) +
#   theme(plot.title = element_text(hjust = 0)) 

```

```{r, echo=FALSE, warning=FALSE, message=FALSE, comment=FALSE}

read_sheets <- function(file){
  xlsx_file <- file
  xlsx_file %>%
    excel_sheets() %>%
    set_names() %>%
    map_df(read_excel, path = xlsx_file, .id = 'sheet_name', trim_ws = TRUE, skip = 1, col_types = "text", range = "A2:DW700") %>% 
    mutate(file_name = file) %>% 
    select(file_name, sheet_name, everything())
}


## read xlsx then csv cache
read_then_csv <- function(sheet, path) {
  pathbase <- path %>%
    basename() %>%
    tools::file_path_sans_ext()
  path %>%
    read_excel(sheet = sheet) %>% 
    write_csv(paste0(pathbase, "-", sheet, ".csv"))
}

## plotting
ggTile_yr_season_site2 <- function(df){
  df %>%
  group_by(yr, season, site2) %>%
  summarise(n= n()) %>%
  ggplot(aes(yr, site2)) +
  geom_tile(aes(fill = n), color = 'white') +
  viridis::scale_fill_viridis(option = "B") +
  facet_wrap(~season) +
  theme(axis.text.x = element_text(angle = 55, hjust = 1, size = 7)) +
  theme(axis.text.y = element_text(size = 7)) +
  facet_wrap(~season)}


ggTile_yr_season_site <- function(df){
  df %>%
  group_by(yr, season, site) %>%
  summarise(n= n()) %>%
  ggplot(aes(yr, site)) +
  geom_tile(aes(fill = n), color = 'white') +
  viridis::scale_fill_viridis(option = "D") +
  theme(axis.text.x = element_text(angle = 55, hjust = 1, size = 7)) +
  theme(axis.text.y = element_text(size = 7)) +
  facet_wrap(~season)} 
# plotting funcs


### aspen tally
## need to work on!
ggTile_asp_denisty01 <- function(df,fillvar, facvar){
  df %>%
  filter(LIVE_DEAD == 'LIVE') %>% 
  # filter(RANGE_TYPE == "core winter range") %>% 
  # filter(SITE_ID == "AC60") %>% select(-contains("UT")) %>% datatable()
  # ggplot(aes(timeClass, DBHclGp01)) +
  ggplot(aes(timeClass, DBHclGp01)) +  
  geom_tile(aes(fill = {{fillvar}}), color = "white", alpha = .2) +
  # geom_text(aes(label = stemTally), size = 3) +
  # facet_wrap(~SITE_ID) +
  facet_wrap(~ {{facvar}}) +
  theme_bw() +
  labs(x = "", y = "", title = "Aspen live stem tallies") +
  # facet_grid(SITE_ID ~ timeClass) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
}

```
  

```{r}
### Table functions
## gt field names

names.gt <- function(df){
  df %>% 
  names() %>% enframe %>% gt::gt() %>% 
    tab_header(title = "field names")
}

names.dt <- function(df){
  df %>% 
  names() %>% enframe %>% 
    DT::datatable(caption = "field names")
}


### Table funcs
# gt_tally_site_plot_yr_season <- function(df){
#   df %>%
#   group_by(yr, plot, season, site) %>%
#   tally() %>%
#     gt::gt() %>% 
#     tab_header(title = "tally")
# }
```

```{r}
## summary funcs
mean_r1 <- function(x){
  round(mean(x, na.rm = TRUE),1)
}

sd_r1 <- function(x){
  round(sd(x, na.rm = TRUE),1)
}

range_r1 <- function(x){
  round(range(x, na.rm = TRUE),1)
}



```

Contact: edgage@rams.colostate.edu

**PROVISIONAL DATA AND ANALYSES**

**Updated: `r format(Sys.time(), '%Y %B %d')`**

This is a working document. All analyses are provisional. 
Please do not distribute.


# Introduction

In 2008, Rocky Mountain National Park (RMNP) began implementation of the Elk and Vegetation Management Plan (EVMP). The EVMP is intended to guide management of elk and vegetation over a 20–yr period, reduce the impacts of elk on vegetation, and bring  target ecosystems into the natural range of variability for elk and vegetation in three target vegetation communities: aspen, montane riparian willow, and upland. The plan relies on the principle of adaptive management and includes management options such as fencing, non-lethal redistribution and culling of elk herds, and active vegetation restoration. Implementing the goals of the EVMP requires monitoring of target vegetation communities. 

RMNP and the U.S. Geological Survey (USGS) developed a vegetation monitoring program focused on EVMP goals (Zeigenfuss et al. 2011
). Monitoring sites were established and baseline data collected from 2006-2009 in core winter range aspen, willow, and upland communities. Subsets of sites have been annually sampled for vegetation offtake by ungulates, while more intensive and extensive sampling has been done on a five-year basis. A second five-year-round of sampling was completed in 2018 and is the focus of this document. Preliminary analyses of data collected in willow, aspen, and upland herbaceous plots in sites on the east side of RMNP and the Kawunechee Valley are presented. 

In addition, we evaluate the effects of the 2012 Fern Lake wildfire that burned through Moraine Park providing a unique opportunity to study willow and aspen recovery after fire in both grazed and ungrazed conditions. EVMP measurements are focused on the core elk winter range, but non-core areas are also included. Data collected in the Kawuneeche Valley (primarily summer range) was collected to provide information on this critical and changing area of the park.


```{r, eval=FALSE}
# This document provides a basic exploration of EVMP files provided by RMNP in October of 2018.  The code and analyses aim to characterize basic data structure, identify problems, and clean and reorganize as needed for plotting and modeling. Specific objectives include identifying issues such as:
# 
# * Inconsistently named/typed factors    
# * Missing values
# * Data values outside of expected range or showing unusual patterns
# Cleaned and archivable data sets will be produced to facilitate future data analysis and aid RMNP in their management goals.

```

# Methods

## Data collection

This report analyzes data from the first 10 years of EVMP monitoring to help assess progress towards program goals. Monitoring in the EVMP program is focused on assessing several community attributes (Zeigenfuss et al. 2011) including:

1. Vegetation offtake by herbivores in riparian shrub (primarily willow, _Salix_ spp.) and upland herbaceous communities assessed through annual subsampling of sites  
2. Willow height and cover resampled every 5 years across plots  
3. Aspen stem density and stem size distribution, assessed every 5 years through a full resampling of sites. 

Protocols detailed in the EVMP monitoring plan were used to collect vegetation data at study plots (Zeigenfuss et al. 2011). Baseline measurements were collected from 2006–2009, with RMNP staff collecting subsequent data. Willow offtake measurements were usually made in May and June, but were delayed in some years to as late as mid-July due to weather.

Upland line intercept transect data were collected in core upland (UC) and upland noncore areas (UNC) along a 30m transect line. Observations included the presence of tracks, scat, burrows, plant damage, or browse. In addition, observation of animal sign were made for elk, deer, moose, and other notable species.

Willow data were collected in the spring and fall each year. Comparison of the spring measurements to the previous fall's shoot measurements allows calculation of winter offtake by herbivores.

```{r, eval=FALSE, echo=FALSE}

# Create a cache of workbook tabs as CSV files
## cache csv. This creates a csv cache of each tab in the workbook.

read_then_csv <- function(sheet, path) {
  pathbase <- path %>%
    basename() %>%
    tools::file_path_sans_ext()
  path %>%
    read_excel(sheet = sheet) %>% 
    write_csv(paste0(pathbase, "-", sheet, ".csv"))
}

path %>%
  excel_sheets() %>%
  set_names() %>% 
  map(read_then_csv, path = path)
```


```{r}
##### READ IN CSV FILES EXPORTED FROM EXCEL TABS 
## all the csv names and paths as list column

csv.all <- tibble(ffname = fs::dir_ls("data/EVMP_data/csv",glob = "*.csv"))

## purrr to read csv into list column
csv.all.lc <- csv.all %>% 
  mutate(data = map(ffname,read_csv))

## 2 improve above: try specifying the NA string on import....

```


```{r}
#### maps
### The following code extracts out the most recent 'site info' file, creates a sf object for plotting and further spatial analysis. Note this is different than below where a different file ('VEG_SITES_MSTR_DATABASE.xlsx') provided by the park is interogated. Here, it's the 'site info' tab within the spreadsheet

# site info
sinfo <- csv.all.lc %>%
  filter(str_detect(ffname, "z2018 Site Info.csv"))

sinfo.df <- sinfo %>% 
  pluck(2) %>% 
  pluck(1)

#### Fix inconsistent labeling of some SITE_ID values
sinfo.df <- sinfo.df %>% 
  mutate(SITE_ID = case_when(SITE_ID == "WC1" ~ "WC01",
                       SITE_ID == "WC2" ~ "WC02",
                       SITE_ID == "WC3" ~ "WC03", 
                       SITE_ID == "WC4" ~ "WC04", 
                       SITE_ID == "WC4" ~ "WC04",
                       SITE_ID == "WC5" ~ "WC05",
                       SITE_ID == "WC6" ~ "WC06", 
                       SITE_ID == "WC7" ~ "WC07", 
                       SITE_ID == "WC8" ~ "WC08",
                       SITE_ID == "WC9" ~ "WC09",
                       SITE_ID == "WNC1" ~ "WNC01",
                       SITE_ID == "WNC1" ~ "WNC01",
                       SITE_ID == "WNC2" ~ "WNC02",
                       SITE_ID == "WNC3" ~ "WNC03", 
                       SITE_ID == "WNC4" ~ "WNC04", 
                       SITE_ID == "WNC4" ~ "WNC04",
                       SITE_ID == "WNC5" ~ "WNC05",
                       SITE_ID == "WNC6" ~ "WNC06", 
                       SITE_ID == "WNC7" ~ "WNC07", 
                       SITE_ID == "WNC8" ~ "WNC08",
                       SITE_ID == "WNC9" ~ "WNC09",
                       SITE_ID == "WK1" ~ "WK01",
                       SITE_ID == "WK2" ~ "WK02",
                       SITE_ID == "WK3" ~ "WK03", 
                       SITE_ID == "WK4" ~ "WK04", 
                       SITE_ID == "WK4" ~ "WK04",
                       SITE_ID == "WK5" ~ "WK05",
                       SITE_ID == "WK6" ~ "WK06", 
                       SITE_ID == "WK7" ~ "WK07", 
                       SITE_ID == "WK8" ~ "WK08",
                       SITE_ID == "WK9" ~ "WK09",
                       TRUE ~ as.character(SITE_ID))
  )

```

```{r site_info_02}
# define path to the veg site master file
path.si <- ("data/EVMP_data/VEG_SITES_MSTR_DATABASE.xlsx")

#### Read in the worksheets and create list of df
# each tab is a df in the list object
si.d <- path.si %>% 
  excel_sheets() %>% 
  set_names() %>%
  map(read_excel, path = path.si) # 

## this retrieved ALL of the tabs. I'll subset the list to get to the desired tabs

site.info.willow <- si.d$'WILLOW SITES MASTER'
site.info.aspen <- si.d$'ASPEN SITES MASTER'
site.info.upland <- si.d$'UPLAND SITES MASTER'
## note: each of the tabs call the UTM coordinate columns something different! For simplicity, I changed them to be consistent in the source file

# and the active master tab. 
site.info.active <- si.d$'ACTIVE VEG SITE LOCATION MASTER'

## gets the names of the individual sheets
# site.info.willow %>% names()
# site.info.aspen %>% names()
# site.info.upland %>% names()

## they don't have the same column names. The following vector is a subset in common
# csel <- c("SITE_ID","UTM_E_NAD83","UTM_N_NAD83","FENCED","VALLEY","UTM_N_NAD83","BURNED")
csel <- c("SITE_ID","UTM_E_NAD83","UTM_N_NAD83","FENCED","BURNED","REMOVED")

site.info.willow <- select(site.info.willow,csel) %>% 
  mutate(pType = "willow")
site.info.aspen <- select(site.info.aspen,csel) %>% 
  mutate(pType = "aspen")
site.info.upland <- select(site.info.upland,csel) %>% 
  mutate(pType = "upland")

## combine the aspen, willow, and upland plots
site.info.all <- rbind(site.info.willow, site.info.aspen, site.info.upland)

# join in the range type from site.info.active tab
rtype <- site.info.active %>% 
  dplyr::select(SITE_ID, WILDERNESS, RANGE_TYPE)

## join in the info
site.info.all <- left_join(site.info.all, rtype, by = "SITE_ID")

```


```{r gtbl_sites}

#### Change the NA range types fields
site.info.all <- site.info.all %>%
  # distinct(RANGE_TYPE)
  mutate(RANGE_TYPE = case_when(grepl("WC", SITE_ID) ~ "core winter range",
                          grepl("WNC", SITE_ID) ~ "non-core winter range",
                          grepl("AC", SITE_ID) ~ "core winter range",
                          grepl("ANC", SITE_ID) ~ "non-core winter range",
                          grepl("UNC", SITE_ID) ~ "non-core winter range",
                          grepl("UC", SITE_ID) ~ "core winter range",
                          grepl("K", SITE_ID) ~ "Kawuneeche Valley"
                          )
         ) 

# site.info.all %>% 
#   dplyr::na_if(.,"NA") %>%  # nice clean way of replacing all the text NA with real NA
#   filter(!is.na(UTM_E_NAD83)) %>% # only keeping points with coordinates
#   filter(!is.na(UTM_N_NAD83)) %>% 
#   filter(!is.na(REMOVED)) %>% 
#   gt::gt() %>%
#   tab_header(title = md("**EVMP plots listed as 'Removed'**"))

####################### Clean #########################
#### Remove records with "NA" for coordinates or ones with
#### Any non-NA for the "REMOVE" field 

site.info.clean <- site.info.all %>% 
  dplyr::na_if(.,"NA") %>%  # replacing all the text NA with real NA
  filter(!is.na(UTM_E_NAD83)) %>% # only keeping points with coordinates
  filter(!is.na(UTM_N_NAD83)) %>% 
  filter(is.na(REMOVED)) %>% 
  filter(SITE_ID != "WK03-R")

## I discovered further down that WK03-R was retained as it is NA for the 'REMOVED' attribute.
## I'm manually removing now, but need to clarify with NPS

# UNC61 is "NA" for fenced. Making fenced = FALSE
# reclass the FENCED == NA to FENCED == N 
# reclass the BURNED == NA to BURNED == N 

site.info.clean <- site.info.clean %>% 
  mutate(FENCED = case_when(is.na(FENCED) ~ "N", 
                            TRUE ~ as.character(FENCED)))

## Reclassify 'NA' for fenced to 'N'
# csv.all.lc.mcro.df <- csv.all.lc.mcro.df %>% 
#   mutate(FENCED = case_when(is.na(FENCED) ~ "N", 
#                             TRUE ~ as.character(FENCED))) %>%  
#   mutate(BURNED = if_else(is.na(BURNED),
#                           "N", BURNED))

# UNC61

```


```{r}

## read in the file with the manually attributed valley type field (this was not fully filled in in the provided data)
## I attributed the empty values visually in ArcGIS.  
vt <- st_read("./data/EVMP_derived/site_info_all_sf.shp", quiet = TRUE)
vt <- vt %>% 
  rename(SITE_ID = SITE_) %>% 
  rename(VALLEY = VALLE) %>% 
  as_tibble() %>% 
  select(SITE_ID, VALLEY)

site.info.clean <- left_join(site.info.clean, vt, by = "SITE_ID")

## recode some of the valley ids
site.info.clean <- site.info.clean %>% 
  mutate(VALLEY = recode(VALLEY, 
                         'FRE' = "HSP")) %>% 
  mutate(VALLEY = recode(VALLEY, 
                         'LHP' = "HSP")) 

## add more valley info from a lookup table
valley_lu <- read_csv("./data/EVMP_derived/VALLEY_lu.csv")

## join in the valley info
site.info.clean <- left_join(site.info.clean, valley_lu, by = "VALLEY") 

# I'm going to convert all these into y and n until I get guidance from Hanem
# I'm also eliminating all the vague burned categories, collapsing them to a binary burned/not-burned category

site.info.clean <- 
  site.info.clean %>% 
  mutate(BURNED = case_when(BURNED == "Not burned" ~ "Not burned",
                            BURNED == "N Y" ~ "Not burned",
                            BURNED == "Completely" ~ "Burned",
                            BURNED == "Moderately" ~ "Burned",
                            BURNED == "Moderately to Completely" ~ "Burned",
                            BURNED == "Y" ~ "Burned",
                            BURNED == "N" ~ "Not burned")
         )

## write csv
# write_csv(site.info.clean, "./data/EVMP_derived/site_info_clean.csv")

```

```{r}
### Tables 
# Problem records lacking coordinates 
site.info.all %>% 
  dplyr::na_if(.,"NA") %>%  # nice clean way of replacing all the text NA with real NA
  filter(!is.na(UTM_E_NAD83)) %>% # only keeping points with coordinates
  filter(!is.na(UTM_N_NAD83)) %>%
  filter(!is.na(REMOVED)) %>% # filter out plots notes as "removed"
  select(-WILDERNESS) %>% 
  # tally()
  gt::gt() %>%
  tab_header(title = md("**EVMP plots listed as 'Removed'**"))
```

A total of 15 plots were removed from subsequent steps. Confirm the final status of these records. 


**Site information:**
```{r}
## create some tables

site.info.clean %>%
  dplyr::select(-REMOVED) %>% 
  datatable(caption = "Valid EVMP plots")


```

```{r}

# site.info.clean %>% 
#   write_csv("./output/tables/evmp_plots_table1.csv")

```

```{r}
# gt.siteinfo <- site.info.clean %>%
#   dplyr::select(-REMOVED) %>% 
#   datatable(caption = "Valid EVMP plots")

# gt.siteinfo <- site.info.clean %>%
#   dplyr::select(-REMOVED) %>% 
#   gt::gt() %>%
#   tab_header(title = md("**Valid EVMP plots from 'site_info' worksheet**")) 

# gt.siteinfo <- gt.siteinfo %>% 
#   tab_style(
#     style = list(
#       cell_fill(color = "lightcyan"),
#       cell_text(weight = "bold")
#       ),
#     locations = cells_data(
#       columns = vars(FENCED),
#       rows = FENCED == "Y")
#   ) %>% 
#   tab_style(
#     style = list(
#       cell_fill(color = "ivory")),
#     locations = cells_data(
#       columns = vars(FENCED),
#       rows = FENCED == "N")
#   ) 
# 
# ## add color for pType
# gt.siteinfo %>% 
#     tab_style(
#     style = list(
#       cell_fill(color = "lightgreen"),
#       cell_text(weight = "bold")
#       ),
#     locations = cells_data(
#       columns = vars(pType),
#       rows = pType == "willow")
#   ) %>% 
#   tab_style(
#     style = list(
#       cell_fill(color = "ivory2"),
#       cell_text(weight = "bold")
#     ),
#     locations = cells_data(
#       columns = vars(pType),
#       rows = pType == "aspen")
#   ) %>% 
#   tab_style(
#     style = list(
#       cell_fill(color = "pink"),
#       cell_text(weight = "bold")
#       ),
#     locations = cells_data(
#       columns = vars(pType),
#       rows = pType == "upland")
#   )

```


```{r}
#### create SF from coordinates
site.info.clean.sf <- site.info.clean %>%
  mutate_at(2:3, as.numeric) %>% 
  st_as_sf(coords = c("UTM_E_NAD83", "UTM_N_NAD83"), crs = 26913)

## write the site info to shapefile
# st_write(site.info.clean.sf, "./data/EVMP_derived/site_info_clean.shp")

```

```{r, eval=FALSE}
## gt: grouped example

site.info.clean.sf %>%
  dplyr::select(-REMOVED) %>%
  group_by(pType) %>% 
  tally() %>% 
  gt::gt() 

gt.siteinfo <- site.info.clean %>%
  dplyr::select(-REMOVED) %>%
  group_by(valley_full, pType) %>% 
  tally() %>% 
  gt::gt() %>% 
  tab_header(title = md("**EVMP plots by valley location**")) 
gt.siteinfo

gt.siteinfo %>% 
  summary_rows(
    #groups = TRUE,
    columns = vars("n"),
    fns = list(TOTAL = "sum"),
    formatter = fmt_number,
    decimals = 0,
    use_seps = TRUE
  )

```


```{r, eval=FALSE, echo=FALSE}
## list column approach
## note quite working yet :)

site.info.clean.sf.nest <- site.info.clean.sf %>% 
  group_by(VALLEY) %>% 
  nest()

# zz <- site.info.clean.sf.nest %>%
#   mutate(gtable = map(.x = data, .f = gt::gt)) #%>%
#   # mutate(vnames = map(.x = data, .f = DT::datatable))
# 
# zz[[2]][[2]]

site.info.clean.sf.nest %>% 
  mutate(plot = map2(data, VALLEY, ~ggplot(data = .x) + theme_tufte() +
       geom_sf(aes(color =FENCED))))
       
       ggtitle(.y) +
       ylab("Year") +
       xlab("Average annual hours worked by persons engaged")))

```


```{r, eval = FALSE, echo = FALSE}
### Raw data in "Site info" tabs from RMNP 

site.info.willow %>% 
  DT::datatable()

site.info.aspen %>% 
  DT::datatable()

site.info.upland %>% 
  DT::datatable()

# site.info.all %>% 
#   skimr::skim() %>% 
#   gt::gt()

```

## Study Area

Excluding plots removed from the data set due to issues like the 2013 flood, their were 241 plots in total. Aproximately 49% (n=118) were willow plots, followed in abundance by aspen and upland plots: 

```{r}
site.info.clean.sf %>%
  as_tibble() %>%
  filter(!is.na(VALLEY)) %>%
  tabyl(pType) %>% 
  rename('Plot type' = pType) %>% 
  gt::gt() %>% 
  fmt_percent(
    columns = vars(percent),
    decimals = 1
    )
```

Plots were most anundant in Moraine Park, followed by Horseshoe Park and Upper Beaver Meadows.

```{r}
site.info.clean.sf %>%
  as_tibble() %>% 
  filter(!is.na(VALLEY)) %>%
  tabyl(valley_full) %>%
  arrange(-n) %>% 
  rename('Location' = valley_full) %>%
  gt::gt() %>% 
  fmt_percent(
    columns = vars(percent),
    decimals = 1
    )
```


```{r}
site.info.clean.sf %>%
  as_tibble() %>% 
  filter(!is.na(VALLEY)) %>%
  tabyl(valley_full, pType) %>%
  rename('Location' = valley_full) %>%
  arrange(-willow) %>% 
  gt::gt() 

```

#### Map of fenced and unfenced areas - all plots

Change basemap or pan and zoom.  

```{r}
# mapviewOptions(basemaps = c("Esri.WorldImagery"), # Esri.WorldShadedRelief "Esri.WorldImagery"
#                vector.palette = colorRampPalette(c("snow", "cornflowerblue", "grey10")),
#                na.color = "magenta",
#                layers.control.pos = "topright")

site.info.clean.sf %>%
  # filter(is.na(valley_full)) %>% 
  # filter(!is.na(RANGE_TYPE)) %>%
  mapview(zcol='FENCED')

## write this to file and enter in Arc?

```


Approximately 21% of plots occur in fenced locations:

```{r}
site.info.clean.sf %>%
  as_tibble() %>% 
  filter(!is.na(VALLEY)) %>%
  tabyl(FENCED) %>% 
  gt::gt() %>%
  fmt_percent(
    columns = vars(percent),
    decimals = 1
    )

```


```{r}
site.info.clean.sf %>%
  as_tibble() %>% 
  filter(!is.na(VALLEY)) %>%
  tabyl(valley_full, FENCED) %>%
  arrange(-(Y)) %>% 
  rename('Location' = valley_full) %>%
  gt::gt() %>% 
  tab_header(title = "Fenced/non-fenced")

```


```{r, eval=FALSE}
# **Table of records with NA for "VALLEY"**

# Note that "location" and "valley" exist in different workbooks/datasets, differ in attributes, and are incompletely attributed. 

# "location" and "valley" exist in different workbooks/datasets, differ in attributes, and are incompletely attributed.

site.info.clean.sf %>% 
  filter(!is.na(VALLEY)) %>%
  datatable(caption = "Records missing VALLEY attributes.")
```


#### Map of burned plots

```{r}

site.info.clean.sf %>%
  filter(EastWest == "East") %>%
  filter(!is.na(BURNED)) %>% 
  # filter(BURNED != 'N') %>%
  # filter(BURNED != 'Not burned') %>%
  mapview(zcol='BURNED',
          map.types = c("Esri.WorldImagery", "Esri.WorldTopoMap"))

```


#### Map of Kawuneeche Valley EVMP sites

```{r}

site.info.clean.sf %>% 
  filter(VALLEY == "KV") %>% 
  mapview::mapview(., zcol = 'pType',
                  map.types = c("Esri.WorldImagery", "Esri.WorldTopoMap"))

```

A total of 17 plots occur in the Kawuneeche Valley: 
```{r}

site.info.clean.sf %>% 
  as_tibble() %>% 
  filter(VALLEY == "KV") %>%
  select(-c(geometry, REMOVED, WILDERNESS, RANGE_TYPE)) %>%
  rename('Valley code' = VALLEY) %>%
  rename('Valley name' = valley_full) %>% 
  gt::gt()

```



```{r}
### note this is still missing as na

site.info.clean.sf %>%
  group_by(valley_full) %>% 
  tally() %>% 
  # na.omit() %>%  ### NEED TO ATTRIBUTE THESE. BUT FOR TESTING....
  ggplot(aes(reorder(valley_full, n),n)) +
  # ggplot( aes(VALLEY, n, size = n, color=VALLEY)) +
  geom_point(color="white", size = 6) +
  geom_pointrange(ymin=0, aes(ymax=n)) +
   geom_point(color="ivory3", size = 10) +
  geom_text(aes(label=n), size=6) +
  # scale_x_log10() +
  theme_minimal() +
  coord_flip() +
  labs(x="Valley", y = "Count", title = "Count of EVMP sampling sites by location")
  
# ggplotly(plotly1)
```



#### Counts by location in Park

```{r}

##
pl.cnt1 <- site.info.clean.sf %>%
  group_by(pType, valley_full) %>% 
  tally() %>% 
  # na.omit() %>%  ### NEED TO ATTRIBUTE THESE. BUT FOR TESTING....
  ggplot(aes(reorder(valley_full, n),n)) +
  # ggplot( aes(VALLEY, n, size = n, color=VALLEY)) +
  # geom_point(color="white", size = 6) +
  geom_point(aes(color = pType), size = 6) +
  geom_pointrange(ymin=0, aes(ymax=n)) +
  geom_point(aes(color=pType), size = 8) +
  # geom_point(color="ivory3", size = 10) +
  geom_text(aes(label=n), size=4) +
  # scale_x_log10() +
  theme_minimal() +
  labs(x="", y = "Count", title = "Count of EVMP sampling sites") +
  coord_flip() +
  theme(legend.position = "bottom")

pl.cnt1
# ggsave("./output/figures/tally_plot_by_valley_type.png", width = 7, height = 5)


pl.cnt2 <- site.info.clean.sf %>%
  group_by(RANGE_TYPE) %>% 
  tally() %>% 
  ggplot(aes(reorder(RANGE_TYPE, n),n)) +
  # ggplot( aes(VALLEY, n, size = n, color=VALLEY)) +
  geom_point(color="white", size = 4) +
  geom_pointrange(ymin=0, aes(ymax=n)) +
   geom_point(color="ivory3", size = 10) +
  geom_text(aes(label=n), size=3) +
  # scale_x_log10() +
  theme_minimal() +
  # coord_flip() +
  theme(axis.text.x = element_text(angle = 30, hjust = 1)) +
  labs(x="", y = "Count", title = "")

pl.cnt2
# ggsave("./output/figures/tally_plot_by_rangeType.png", width = 7, height = 5)


pl.cnt1.cnt2 <- cowplot::plot_grid(pl.cnt1, pl.cnt2, labels = "AUTO")
# pl.cnt1.cnt2

# ggsave(plot = pl.cnt1.cnt2, filename = "./output/figures/twoPanel_valleyCnt_rangeCnt2.png", width = 8, height = 5, dpi = 300)


site.info.clean.sf %>%
  as_tibble() %>% 
  select(-geometry) %>% 
  group_by(RANGE_TYPE, pType) %>% 
  tally() %>% 
  gt()


```



```{r, eval=FALSE}
#### Records with "NA" for "VALLEY"
# site.info.clean.sf %>%
#   filter(is.na(VALLEY)) %>% 
#   mapview()

site.info.clean.sf %>%
  filter(!is.na(VALLEY)) %>%
  as_tibble() %>% 
  datatable()
## cleaned above so none...
```

#### Counts of plots in fenced and unfenced contexts

```{r}

# site.info.clean.sf %>%
#   group_by(FENCED,pType) %>%
#   tally() %>%
#   # na.omit() %>%  ### NEED TO ATTRIBUTE THESE. BUT FOR TESTING....
#   ggplot(aes(reorder(FENCED, n),n)) +
#   # ggplot( aes(VALLEY, n, size = n, color=VALLEY)) +
#   geom_point(color="white", size = 6) +
#   geom_pointrange(ymin=0, aes(ymax=n)) +
#    geom_point(color="ivory3", size = 10) +
#   geom_text(aes(label=n), size=6) +
#   # scale_x_log10() +
#   theme_bw() +
#   # theme_minimal() +
#   coord_flip() +
#   labs(y="Count", x = "Range type", title = "Count of EVMP sampling sites by 'Range type'") +
#   facet_wrap(~pType)

pl.hm1 <- site.info.clean.sf %>%
  filter(!is.na(FENCED)) %>%
  group_by(FENCED,valley_full) %>%
  tally() %>%
  # na.omit() %>%  ### NEED TO ATTRIBUTE THESE. BUT FOR TESTING....
  ggplot(aes(FENCED, valley_full)) +
  geom_tile(aes(fill = n), color= 'white') +
  # geom_point(color="white", size = 6) +
  geom_text(aes(label=n), size=8, color = 'white') +
  # scale_x_log10() +
  # theme_bw() +
  theme_minimal() +
  # scale_fill_gradient(low = "ivory4",high = "black") +
  scale_fill_viridis() +
  # theme_minimal() +
  # coord_flip() +
  labs(x="Fenced", y = "", title = "Count of EVMP sampling sites",subtitle = "By valley and and fenced status")

# ggsave(plot = pl.hm1, filename = "./output/figures/cnt_plot_valley_x_fenced.png", width = 5, height = 4, dpi = 300)

pl.hm2 <- site.info.clean.sf %>%
  filter(!is.na(FENCED)) %>% 
  group_by(FENCED,pType) %>% 
  tally() %>% 
  # na.omit() %>%  ### NEED TO ATTRIBUTE THESE. BUT FOR TESTING....
  ggplot(aes(FENCED, pType)) +
  geom_tile(aes(fill = n), color= 'white') +
  # geom_point(color="white", size = 6) +
  geom_text(aes(label=n), size=8, color = 'white') +
  # scale_x_log10() +
  # theme_bw() +
  theme_minimal() +
  scale_fill_viridis() +
  # scale_fill_gradient(low = "ivory4",high = "black") +
  # theme_minimal() +
  # coord_flip() +
  labs(x="Fenced", y = "", title = "Count of EVMP sampling sites", subtitle = "By plot type and fenced status")

# ggsave(plot = pl.hm2, filename = "./output/figures/cnt_ptype_x_fenced.png", width = 5, height = 4, dpi = 300)

cow1 <- cowplot::plot_grid(pl.hm1, pl.hm2, labels = "AUTO", ncol=2)
cow1
# ggsave(plot = cow1, filename = "./output/figures/cnt_ptype_valle_x_fenced.png", width = 5, height = 4, dpi = 300)

```


```{r}
#### Cleaning
# data.entry(site.info.all)

```

```{r, eval = FALSE}
## scrap: creat functions to create basemaps with ggplot
library(ggmap)  # you may have to use install.packages to install it first
b <- ggmap::bbox(lnd)
(lnd.b1 <- ggmap(get_map(location = b)))  # download map data for the lnd data and plot

ggmap::bb2bbox()

```


```{r}
## nested by range type 

site.info.clean.sf.nest <- site.info.clean.sf %>% 
  filter(!is.na(RANGE_TYPE)) %>% 
  group_by(RANGE_TYPE) %>% 
  nest()

```


```{r, eval=TRUE}
##ggmap site maps. Need base maps

site.info.clean.sf.nest <- site.info.clean.sf.nest %>% 
  mutate(plot = map2(data,RANGE_TYPE, ~ggplot(data = .x) + theme_bw() +
                       geom_sf() +
                       labs(title = .y))) 
# library(OpenStreetMap)

```

```{r, eval = FALSE}
## pring the ggmaps
mm1 <- site.info.clean.sf.nest %>% 
  pluck(3) %>% pluck(1) 
mm1

mm2 <- site.info.clean.sf.nest %>% 
  pluck(3) %>% pluck(2)
mm2

mm3 <- site.info.clean.sf.nest %>% 
  pluck(3) %>% pluck(3)
mm3

# cowplot::plot_grid(mm1,mm2,mm3,nrow = 1)
# file_names <- paste0(country_list, ".pdf")
# map2(paste0(plots$country, ".pdf"), plots$plot, ggsave)  

# ### 
# sinfo.sf %>% 
#   group_by(SITE_TYPE) %>% 
#   nest() %>% 
#   walk2(.x = data,.f = mapview)
#   mutate(plot2 = map(.$SITE_TYPE, mapview)) 
```


```{r}

site.info.clean.sf.nest <- site.info.clean.sf.nest %>% 
  mutate(plot2_MV = map(data,mapview)) 

### this prints them all out.
# site.info.clean.sf.nest %>%
#   pluck(4)
## seemingly just to console, not when knit for mapview
## BUT it does work for ggplot objects...
# site.info.clean.sf.nest %>%
#   pluck(3)

```



**East-side Core Winter Range (WC) map**

```{r, fig.align='center'}

## map: Core Winter Range
site.info.clean.sf.nest %>% 
  pluck(2) %>% pluck(1) %>% 
  # names()
  mapview(zcol = "FENCED")

```

**East-side Non-core Winter Range (WC) map**
```{r, fig.align='center'}

## map: KV
site.info.clean.sf.nest %>% 
  pluck(2) %>% pluck(3) %>% 
  mapview(zcol = "FENCED")

```


**West-side Kawuneeche Valley (WK) map**
```{r, fig.align='center'}

## map: KV
site.info.clean.sf.nest %>% 
  pluck(2) %>% pluck(2) %>% 
  mapview(zcol="FENCED")

# site.info.clean.sf.nest %>% 
#   pluck(2) %>% 
#   pluck(2) %>%
#   ggplot() +
#   geom_sf(aes(color = FENCED)) +
#   theme_minimal()

```

Raw data files entered by RMNP staff from field data forms were processed using functions in in the R statistical package. Raw data were provided as 4 Excel files, with data split by year and type into various tabs. Data were consolidated and to facilitate cleaning and comparisons.      

```{r}
### Data cleaning and wrangling



# list of files, tidyverse approach: 
# file.listing <- dir_info(path = "./data/EVMP_data/TenYearReview", recurse = TRUE) %>%
#   filter(type == "file", permissions == "u+r", size > "10KB") %>%
#   arrange(desc(size)) %>%
#   View()
#   dplyr::select(path, size)

# datatable(file.listing, rownames = FALSE, caption = "List of files provided by RMNP 2018-10-10")

## base R approach
file.listing <- list.files(path = "./data/EVMP_data/TenYearReview") %>% 
  enframe() %>% 
  select(value) %>% 
  rename(fileName = value)

knitr::kable(file.listing, rownames = FALSE, row.names = FALSE, col.names = "file name", caption = "Raw files provided by RMNP staff.")

```


```{r}
### Willow cumulative data baseline through 2018
#### There are two duplicate sets of files, one with a 'z' in the name, one without, but otherwise the same. In this chunk, picking one set (the zed set)

csv.all.lc <- csv.all.lc %>% 
  filter(str_detect(ffname, "z")) 

```

```{r}
######### CREATE TYPE FIELD #########
## this will make parsing variables in into groups easier  

csv.all.lc <- csv.all.lc %>% 
  mutate(file_name_abr = str_replace(string = ffname, pattern = "data/EVMP_data/csv/Willow_Cumulative_Data_Baseline_Through_2018-", replacement = ""))

## case when into type
csv.all.lc <- csv.all.lc %>% 
  dplyr::select(-ffname) %>%
  mutate(vType = case_when(grepl("Macro", file_name_abr) ~ "Macroplot",
                          grepl("site", file_name_abr, ignore.case = TRUE) ~ "Site_info",
                          grepl("Key", file_name_abr, ignore.case = TRUE) ~ "Key",
                          grepl("Line", file_name_abr, ignore.case = TRUE) ~ "Line_int"
                          )
         )

```


```{r}
## Variable names across input files 
# extract the field names from each csv
csv.all.lc <- csv.all.lc %>% 
  mutate(field_names = map(data, names)) 
  
# unnest to get at field names
# across all csv files
csv.all.lc %>% 
  unnest(field_names) %>% 
  distinct(file_name_abr,field_names) %>% 
  datatable(rownames = FALSE, caption = "Distinct field names acrosss all csv files correponding to tabs in master workbooks provided by RMNP.")

#### Distinct field names via unnest()
# csv.all.lc %>%
#   unnest(field_names) %>%
#   distinct(ffname,field_names) %>%
#   datatable()

```

```{r}
## just line intercept

#### Line intercept
csv.all.lc.li <- csv.all.lc %>% 
  filter(vType == "Line_int") 

# Distinct variable names across all input csv files for just line intercept plot
# csv.all.lc.li %>% 
#   unnest(field_names) %>% 
#   distinct(file_name_abr,field_names) %>% 
#   # write_csv("output/temp_4_review/distinc_line_in_names.csv")
#   datatable(rownames = FALSE, caption = "Distinct variable names for line intercept files.")

```



```{r}
#### FUNCTIONS 
#### Select multiple columns. To combine, need the same fields to be present in each tab.

filtFunSel <- function(x){
  x %>% dplyr::select(c(DATE,
                      SITE_TYPE,
                      SITE_NUMBER,
                      SITE_ID,
                      SPECIES_CODE,
                      # SHRUB_INTERCEPT_START_M,
                      # SHRUB_INTERCEPT_STOP_M,
                      MAX_HEIGHT_CM,
                      #DEAD,
                      BROWSED,
                      INTERCEPT_LENGTH_M,
                      GENUS))
}


### the above is used throoughout below
# but now I woant to grab the shrub intercept bits
filtFunSel_li <- function(x){
  x %>% dplyr::select(c(DATE,
                      SITE_TYPE,
                      SITE_NUMBER,
                      SITE_ID,
                      SPECIES_CODE,
                      SHRUB_INTERCEPT_START_M,
                      SHRUB_INTERCEPT_STOP_M,
                      MAX_HEIGHT_CM,
                      DEAD,
                      BROWSED,
                      INTERCEPT_LENGTH_M,
                      GENUS))
}

# create new list column with the selected rows as specfied in the function
csv.all.lc.li <- csv.all.lc.li %>% 
  mutate(data.sel = map(.x = data, filtFunSel))

# csv.all.lc.li.cov <- csv.all.lc.li %>% 
#   mutate(data.sel = map(.x = data, filtFunSel_li))

## purrr ninja move:
csv.all.lc.li.df <- csv.all.lc.li %>% 
  pluck(1) %>%
  map(filtFunSel) %>% 
  reduce(.f = rbind)
# yay, pluck()!

## Why can't anything be simple....
# just discovered that SITE_ID columns are NOT CONSISTENTLY NAMED
# eg WC1 and WC01

# csv.all.lc.mcro.df %>% 
#   filter(SITE_NUMBER <10) %>% 
#   distinct(SITE_ID) %>% 
#   datapasta::vector_paste()

csv.all.lc.li.df <- csv.all.lc.li.df %>% 
  mutate(SITE_ID = case_when(SITE_ID == "WC1" ~ "WC01",
                       SITE_ID == "WC2" ~ "WC02",
                       SITE_ID == "WC3" ~ "WC03", 
                       SITE_ID == "WC4" ~ "WC04", 
                       SITE_ID == "WC4" ~ "WC04",
                       SITE_ID == "WC5" ~ "WC05",
                       SITE_ID == "WC6" ~ "WC06", 
                       SITE_ID == "WC7" ~ "WC07", 
                       SITE_ID == "WC8" ~ "WC08",
                       SITE_ID == "WC9" ~ "WC09",
                       SITE_ID == "WNC1" ~ "WNC01",
                       SITE_ID == "WNC1" ~ "WNC01",
                       SITE_ID == "WNC2" ~ "WNC02",
                       SITE_ID == "WNC3" ~ "WNC03", 
                       SITE_ID == "WNC4" ~ "WNC04", 
                       SITE_ID == "WNC4" ~ "WNC04",
                       SITE_ID == "WNC5" ~ "WNC05",
                       SITE_ID == "WNC6" ~ "WNC06", 
                       SITE_ID == "WNC7" ~ "WNC07", 
                       SITE_ID == "WNC8" ~ "WNC08",
                       SITE_ID == "WNC9" ~ "WNC09",
                       SITE_ID == "WK1" ~ "WK01",
                       SITE_ID == "WK2" ~ "WK02",
                       SITE_ID == "WK3" ~ "WK03", 
                       SITE_ID == "WK4" ~ "WK04", 
                       SITE_ID == "WK4" ~ "WK04",
                       SITE_ID == "WK5" ~ "WK05",
                       SITE_ID == "WK6" ~ "WK06", 
                       SITE_ID == "WK7" ~ "WK07", 
                       SITE_ID == "WK8" ~ "WK08",
                       SITE_ID == "WK9" ~ "WK09",
                       TRUE ~ as.character(SITE_ID))
  )


## join in additional site info from the master plot list
csv.all.lc.li.df <- left_join(csv.all.lc.li.df, site.info.clean, by = 'SITE_ID')

```

```{r}
## add fields/convert types 
csv.all.lc.li.df <- csv.all.lc.li.df %>%
  mutate(DATE = as.Date(DATE)) %>% 
  mutate(yr = as.factor(year(DATE))) %>%
  mutate(mo = month(DATE))

## convert "NA" for fencing to "N". CHECK WITH PARK ON THIS

csv.all.lc.li.df <- csv.all.lc.li.df %>% 
  mutate(FENCED = case_when(is.na(FENCED) ~ "N",
                            TRUE ~ as.character(FENCED)))


# csv.all.lc.li.df %>% 
#   filter(!is.na(MAX_HEIGHT_CM)) %>%
#   # names() %>% 
#   group_by(yr,SITE_TYPE, SITE_NUMBER, SITE_ID, MAX_HEIGHT_CM) %>% 
#   summarize()

```



```{r}

## Create a spatial lookup table for joining site info [in workbook tab].
sp.lu <- sinfo.df %>%
  dplyr::select(-c(SITE_TYPE,DATE,SITE_NUMBER, GPS_ACCURACY_M))

## make sure the 'SITE_ID' columns are consistent
sp.lu <- sp.lu %>% 
  mutate(SITE_ID = case_when(
    SITE_ID == "WC1" ~ "WC01",
                       SITE_ID == "WC2" ~ "WC02",
                       SITE_ID == "WC3" ~ "WC03", 
                       SITE_ID == "WC4" ~ "WC04", 
                       SITE_ID == "WC4" ~ "WC04",
                       SITE_ID == "WC5" ~ "WC05",
                       SITE_ID == "WC6" ~ "WC06", 
                       SITE_ID == "WC7" ~ "WC07", 
                       SITE_ID == "WC8" ~ "WC08",
                       SITE_ID == "WC9" ~ "WC09",
                       SITE_ID == "WNC1" ~ "WNC01",
                       SITE_ID == "WNC1" ~ "WNC01",
                       SITE_ID == "WNC2" ~ "WNC02",
                       SITE_ID == "WNC3" ~ "WNC03", 
                       SITE_ID == "WNC4" ~ "WNC04", 
                       SITE_ID == "WNC4" ~ "WNC04",
                       SITE_ID == "WNC5" ~ "WNC05",
                       SITE_ID == "WNC6" ~ "WNC06", 
                       SITE_ID == "WNC7" ~ "WNC07", 
                       SITE_ID == "WNC8" ~ "WNC08",
                       SITE_ID == "WNC9" ~ "WNC09",
                       SITE_ID == "WK1" ~ "WK01",
                       SITE_ID == "WK2" ~ "WK02",
                       SITE_ID == "WK3" ~ "WK03", 
                       SITE_ID == "WK4" ~ "WK04", 
                       SITE_ID == "WK4" ~ "WK04",
                       SITE_ID == "WK5" ~ "WK05",
                       SITE_ID == "WK6" ~ "WK06", 
                       SITE_ID == "WK7" ~ "WK07", 
                       SITE_ID == "WK8" ~ "WK08",
                       SITE_ID == "WK9" ~ "WK09",
                       TRUE ~ as.character(SITE_ID))
  )

# csv.all.lc.li.df <- left_join(csv.all.lc.li.df, sp.lu, by= "SITE_ID")

```

```{r, eval=FALSE}

csv.all.lc.li.df %>% 
  skimr::skim() %>% 
  kable(caption = "Basic information on 'line intercept' imported dataset.")

```



```{r, eval=FALSE, echo=FALSE}

#  NOT run. A work in in progress

## filter to 2013 and 2018
csv.all.lc.li.df %>% 
  filter(yr == 2013 | yr == 2018) %>%
  # group_by(SITE_ID,SPECIES_CODE,DATE) %>%
  # names()
  group_by(SITE_ID,SITE_TYPE, FENCED, SPECIES_CODE,yr) %>% 
  summarise(mean.max = mean(MAX_HEIGHT_CM, na.rm=TRUE), sd.max = sd(MAX_HEIGHT_CM, na.rm=TRUE), n.max = n()) %>% 
  # filter(SPECIES_CODE == "SAMO") %>% 
  ungroup() %>%
  filter(n.max >1) %>% 
  ggplot(aes(yr,mean.max)) +
  geom_point() +
  geom_line(aes(x=yr, y = mean.max)) +
  facet_wrap(~SPECIES_CODE)

plotly::ggplotly()
# tidyr::spread(key = yr, value = MAX_HEIGHT_CM, convert = FALSE)
```


```{r}
#### Macroplot
csv.all.lc.mcro <- csv.all.lc %>% 
  filter(vType == "Macroplot") 

```

```{r, eval=FALSE}
csv.all.lc.mcro %>% 
  unnest(field_names) %>% 
  # tabyl(file_name_abr)
  tabyl(file_name_abr,field_names) %>% 
  # write_csv("output/temp_4_review/macroplot_fld_names.csv")
  datatable(rownames = FALSE, caption = "Macroplot inventory variable names.")

```


```{r}
FunSelMacro <- function(x){
  x %>% dplyr::select(c(DATE,
                      SITE_TYPE,
                      SITE_NUMBER,
                      SITE_ID,
                      SPECIES_CODE,
                      PERCENT_PLANT_IN_PLOT,
                      CANOPY_DIA_1_CM,
                      CANOPY_DIA_2_CM,
                      PLANT_HT_CM,
                      HT_TO_TALLEST_BUDSCAR_CM))
}


csv.all.lc.mcro <- csv.all.lc.mcro %>% 
  mutate(data.sel = map(.x = data, FunSelMacro))

# csv.all.lc.li %>% 
#   unnest(field_names) %>% 
#   distinct(field_names)%>% 
#   datapasta::dpasta()


## purrr ninja move:
csv.all.lc.mcro.df <- csv.all.lc.mcro %>% 
  pluck(1) %>%
  map(FunSelMacro) %>% 
  reduce(.f = rbind)

# SITE_ID is not consistent.
# recode
csv.all.lc.mcro.df <- csv.all.lc.mcro.df %>% 
  mutate(SITE_ID = case_when(SITE_ID == "WC1" ~ "WC01",
                       SITE_ID == "WC2" ~ "WC02",
                       SITE_ID == "WC3" ~ "WC03", 
                       SITE_ID == "WC4" ~ "WC04", 
                       SITE_ID == "WC4" ~ "WC04",
                       SITE_ID == "WC5" ~ "WC05",
                       SITE_ID == "WC6" ~ "WC06", 
                       SITE_ID == "WC7" ~ "WC07", 
                       SITE_ID == "WC8" ~ "WC08",
                       SITE_ID == "WC9" ~ "WC09",
                       SITE_ID == "WNC1" ~ "WNC01",
                       SITE_ID == "WNC1" ~ "WNC01",
                       SITE_ID == "WNC2" ~ "WNC02",
                       SITE_ID == "WNC3" ~ "WNC03", 
                       SITE_ID == "WNC4" ~ "WNC04", 
                       SITE_ID == "WNC5" ~ "WNC05",
                       SITE_ID == "WNC6" ~ "WNC06", 
                       SITE_ID == "WNC7" ~ "WNC07", 
                       SITE_ID == "WNC8" ~ "WNC08",
                       SITE_ID == "WNC9" ~ "WNC09",
                       SITE_ID == "WK1" ~ "WK01",
                       SITE_ID == "WK2" ~ "WK02",
                       SITE_ID == "WK3" ~ "WK03", 
                       SITE_ID == "WK4" ~ "WK04", 
                       SITE_ID == "WK4" ~ "WK04",
                       SITE_ID == "WK5" ~ "WK05",
                       SITE_ID == "WK6" ~ "WK06", 
                       SITE_ID == "WK7" ~ "WK07", 
                       SITE_ID == "WK8" ~ "WK08",
                       SITE_ID == "WK9" ~ "WK09",
                       TRUE ~ as.character(SITE_ID))
  )

```

```{r, echo=FALSE}
csv.all.lc.mcro.df <- csv.all.lc.mcro.df %>% 
  mutate(yr = year(DATE)) %>% 
  mutate(mo = lubridate::month(DATE))
```

```{r, echo=FALSE}

### join in the spatial/site info
csv.all.lc.mcro.df <- left_join(csv.all.lc.mcro.df, sp.lu, by = "SITE_ID")

```


```{r, eval=FALSE}
## not working anymore. 202-05-01
#### Missingness across years 
temp.m <- csv.all.lc.li.df %>% 
  mutate(yr = year(DATE))

temp.m %>% 
  mutate(yr = as.factor(yr)) %>%
  naniar::gg_miss_fct(yr) +
  theme_minimal() + 
  labs(title = 'Missing data', y = "", x="Year", fill = "% missing")

mplot1

```


```{r, eval=FALSE}
## line intercept: missing data analysis
csv.all.lc.li.df %>% 
  group_by(yr) %>% 
  nest() %>% 
  map(data, naniar::vis_miss)

naniar::vis_miss(csv.all.lc.li.df) %>% 
  facet_wrap(~)
```



```{r, eval=FALSE}
## line intercept: missing data analysis
#### Missingness across months 
csv.all.lc.li.df %>% 
  mutate(mo = month(DATE)) %>% 
  naniar::gg_miss_fct(SITE_ID) +
  labs(title = "Variables: Missing data by month", x="Month") +
  scale_fill_viridis(discrete = FALSE, option = "A")

## note the site info variables are not all present in the equiv var in the
## li data. For example 'BURNED'  and 'UTM_N_NAD83'

```


```{r, eval=FALSE}
### macroplot

csv.all.lc.mcro <- csv.all.lc %>% 
  filter(vType == "Macroplot") 

# fields not in all of the tabs
csv.all.lc.mcro %>% 
  unnest(field_names) %>% 
  group_by(field_names) %>%
  tally() %>% 
  arrange(n) %>% 
  filter(n<6) %>% 
  # distinct(file_name_abr,field_names) %>% 
  # write_csv("output/temp_4_review/macroplot_fld_names.csv")
  datatable(rownames = FALSE, caption = "Macroplot inventory variable NOT present in every year's tab")

# csv.all.lc.mcro %>% 
#   unnest(field_names) %>% 
#   group_by(field_names) %>%
#   tally() %>% 
#   arrange(n) %>% 
#   filter(n==6) %>% 
#   select(field_names) %>% 
#   datapasta::vector_paste_vertical()

csv.all.lc.mcro %>% 
  unnest(field_names) %>% 
  # tabyl(file_name_abr)
  tabyl(file_name_abr,field_names) %>% 
  # write_csv("output/temp_4_review/macroplot_fld_names.csv")
  datatable(rownames = FALSE, caption = "Macroplot inventory variable names.")

```


```{r, eval=TRUE}

# Macroplot processing
# use a custom function to select columns before rbinding
# note these are different field names than li that need to be matched
# this function snags only those fields in common between all of the tabs

FunSelMcro <- function(x){
  x %>% dplyr::select(c(CANOPY_DIA_1_CM, 
                        CANOPY_DIA_2_CM, 
                        DATE, 
                        GENUS, 
                        HT_TO_TALLEST_BUDSCAR_CM,
                        PERCENT_PLANT_IN_PLOT, 
                        PLANT_HT_CM, 
                        SITE_ID, 
                        SITE_NUMBER, 
                        SITE_TYPE, 
                        SPECIES_CODE))
    }


## apply function to select variables in common between all csv
csv.all.lc.mcro <- csv.all.lc.mcro %>% 
  mutate(data.sel = map(.x = data, FunSelMcro)) %>% 
  select(-field_names)

csv.all.lc.mcro <- csv.all.lc.mcro %>% 
  mutate(field_names = map(data.sel, names))

# csv.all.lc.mcro %>% 
#   unnest(field_names) %>% 
#   # tabyl(file_name_abr)
#   tabyl(file_name_abr,field_names) %>% 
#   # write_csv("output/temp_4_review/macroplot_fld_names.csv")
#   datatable(rownames = FALSE, caption = "Macroplot inventory variable names.")



```

```{r}
## combine all using purrr, ninja-style:
# csv.all.lc.mcro.df <- csv.all.lc.mcro %>% 
#   pluck(4) %>% # note the specific index position
#   reduce(.f = rbind) # did this above

## add yr and month columns
csv.all.lc.mcro.df <- csv.all.lc.mcro.df %>% 
  mutate(yr = year(DATE)) %>% 
  mutate(mo = lubridate::month(DATE))

## join the site info
# csv.all.lc.mcro.df <- left_join(csv.all.lc.mcro.df, site.info.clean, by = "SITE_ID")

# View(csv.all.lc.mcro.df)
```


```{r, eval=FALSE, echo=FALSE}
## species codes are a mess
# create a lookup table
csv.all.lc.mcro.df %>%
  mutate(SPECIES_CODE = toupper(SPECIES_CODE)) %>%
  distinct(SPECIES_CODE) # %>% 
  # datapasta::tribble_paste()

# sp.lu <- tibble::tribble(
#                   ~SPECIES_CODE,
#                          "DAFR",
#                          "SAMO",
#                          "SAPL",
#                          "BEGL",
#                          "SAGE",
#                          "BEOC",
#                          "SAXX",
#                          "NONE",
#                          "ACGL",
#                          "ALIN",
#                          "JUCO",
#                          "PIPU",
#                          "POTR",
#                          "RICE",
#                          "RIIN",
#                          "RUID",
#                          "RUXX",
#                          "SABE",
#                          "PICO",
#                          "SADR",
#                          "SALA",
#                          "SAPE",
#                          "ROWO",
#                          "POAN",
#                          "BEXX",
#                          "RUDE",
#                          "DAFL",
#                          "LOIN",
#                              NA,
#                          "SALU",
#                          "SAWO",
#                          "SALE",
#                          "RINN",
#                          "RUIN",
#                          "SABO",
#                          "SABR",
#                          "SAER"
#                   )

# create skeleton for populating a species lookup table
# write_csv(sp.lu, "./data/EVMP_derived/species_code_lu.csv")  
# manually enter codes in excel and bring back in for joining
# note that there are some questionable species codes that will require 
# more help from NPS to resolve

## read in lu table
```

```{r}
## more cleaning...
## change case on species code (there is currently a mix of upper and lower cases)
csv.all.lc.mcro.df <- csv.all.lc.mcro.df %>% 
  mutate(SPECIES_CODE = toupper(SPECIES_CODE))

## add in the look up table
spp.lu <- read_csv("./data/EVMP_derived/species_code_lu.csv")


## problems with 'Fenced' status. Many NA
## Presuming here that all NA are not fenced -- CONFIRM WITH NPS

## Reclassify 'NA' for fenced to 'N'
csv.all.lc.mcro.df <- csv.all.lc.mcro.df %>% 
  mutate(FENCED = case_when(is.na(FENCED) ~ "N", 
                            TRUE ~ as.character(FENCED))) 


# csv.all.lc.mcro.df %>% 
#   group_by(SITE_ID, FENCED) %>% 
#   tally()

```

```{r}
csv.all.lc.mcro.df %>% 
  names()
  visdat::vis_dat()
```


```{r write_macroplot2disk, eval=FALSE}
## write this to disk
# write_csv(csv.all.lc.mcro.df, "./data/EVMP_derived/macroplot_derived.csv")
```


# Results 

## Shrub height [line intercept]

```{r write_li_to_disk, eval = FALSE}
csv.all.lc.li.df

# write_csv(csv.all.lc.li.df, "./data/EVMP_derived/li_derived.csv")
```


```{r, echo=FALSE}
# > From discussions with HA in the field, the orientation of line-intercept transects may not have had a consistent orientation from sampling interval to interval.
```

**Max shrub height in-line intercept: Core winter range**
```{r}
csv.all.lc.li.df %>% 
  filter(SITE_TYPE == "WC") %>% 
  mutate(yr = as.character(yr)) %>%
  # mutate(yr = as.integer(yr)) %>%
  # mutate(yr = as.character(yr)) %>% 
  # filter(yr == 2013 | yr == 2018) %>%
  filter(yr == 2008 | yr == 2013 | yr == 2018) %>%
  # mutate(yr = as.double(yr)) %>%
  ggplot(aes(yr, MAX_HEIGHT_CM)) +
  geom_boxplot(aes(fill = FENCED), outlier.shape = NA) +
  ylim(0,300) +
  labs(x="Year", y= "Height (cm)", title = "Maximum shrub height", subtitle = "All shrub species in line intercept plots") +
  scale_fill_manual(values = c("ivory2","grey")) +
  theme_bw() +
  theme(axis.text.x=element_text(angle = 45, hjust = 1)) #+
  # facet_grid(.~SITE_TYPE)

# ggsave("./output/figures_exported/all_shrub_LI_boxplot_WC.png", width = 6.5, height = 4.875)

```

# and a table for above
```{r}
csv.all.lc.li.df %>% 
  filter(SITE_TYPE == "WC") %>% 
  mutate(yr = as.character(yr)) %>%
  # mutate(yr = as.integer(yr)) %>%
  # mutate(yr = as.character(yr)) %>% 
  # filter(yr == 2013 | yr == 2018) %>%
  filter(yr == 2008 | yr == 2013 | yr == 2018) %>% 
  group_by(yr, FENCED) %>% 
  summarise_if(.predicate = is.numeric,.funs = median,na.rm=TRUE) %>% 
  select(FENCED, yr, MAX_HEIGHT_CM) %>% 
  gt() %>% 
  tab_header(title = "Median max height", subtitle = "All shrub species, all range types")

```


#### line intercept core winter range

```{r}
# csv.all.lc.li.df %>% 
#   distinct(SPECIES_CODE) %>% 
#   gt::gt()

## yr,FENCED, SPECIES_CODE
tabl.li.meanht1 <- csv.all.lc.li.df %>% 
  # distinct(SITE_TYPE)
  # filter(SITE_TYPE != "WNC") %>%
  filter(SITE_TYPE == "WC") %>% 
  mutate(yr = as.character(yr)) %>%
  # mutate(yr = as.integer(yr)) %>%
  # mutate(yr = as.character(yr)) %>% 
  # filter(yr == 2013 | yr == 2018) %>%
  filter(SPECIES_CODE != "NONE" & SPECIES_CODE != "SAXX") %>% 
  filter(yr == 2008 | yr == 2009 | yr == 2013 | yr == 2018) %>%
  mutate(yr_cat = case_when(yr == "2008" | yr == "2009" ~ "bl",
                            TRUE ~ yr)) %>% 
  group_by(yr_cat,FENCED, SPECIES_CODE) %>%
  # janitor::clean_names() %>% 
  summarise(mean.max.ht = round(mean(MAX_HEIGHT_CM, na.rm=TRUE),0)) %>% 
  pivot_wider(names_from = yr_cat, values_from = mean.max.ht)
  
tabl.li.meanht1 <- tabl.li.meanht1 %>%
  janitor::clean_names()

# tabl.li.meanht1 %>%
#   gt()

```

```{r}
tabl.li.meanht1 <- tabl.li.meanht1 %>% 
  as_tibble() %>% 
  mutate(gross_diff_bl_13 = x2013 - bl) %>%
  mutate(gross_diff_bl_18 = x2018 - bl) %>% 
  mutate(gross_diff_13_18 = x2018 - x2013) %>% 
  mutate(perc_diff_13_18 = (gross_diff_bl_13 - bl)/bl) %>% 
  mutate(perc_diff_bl_13 = (gross_diff_bl_18 - bl)/bl) %>%
  mutate(perc_diff_bl_18 = (gross_diff_13_18 - x2013)/x2013) 

  
tabl.li.meanht1 %>% 
  datatable()

# tabl.li.meanht1 %>% 
#   gt::gt()
```


### Height summary
```{r}
##
csv.all.lc.li.df %>% 
  # filter(!is.na(FENCED)) %>% 
  filter(!is.na(MAX_HEIGHT_CM)) %>%
  # group_by(yr,SITE_TYPE, FENCED, SITE_ID, SPECIES_CODE) %>%
  filter(SITE_TYPE == "WC") %>% 
  group_by(yr,SITE_TYPE, FENCED, SPECIES_CODE, BURNED) %>%
  summarise(mean.max.ht = round(mean(MAX_HEIGHT_CM, na.rm=TRUE),1),
            sd.max.ht = round(sd(MAX_HEIGHT_CM, na.rm=TRUE),1)) %>% 
  filter(FENCED != "Y_but_fence_down_since_2013") %>% 
  filter(SPECIES_CODE != "SAXX") %>% 
  datatable() # kable(caption = "Core winter range")


```


```{r}
# Shrub Line Intercept Datataset 

csv.all.lc.li.df %>% 
  filter(!is.na(FENCED)) %>% 
  filter(!is.na(MAX_HEIGHT_CM)) %>%
  # group_by(yr,SITE_TYPE, FENCED, SITE_ID, SPECIES_CODE) %>%
  filter(SITE_TYPE == "WC") %>% 
  group_by(yr,SITE_TYPE, FENCED, SPECIES_CODE) %>%
  summarise(mean.max.ht = round(mean(MAX_HEIGHT_CM, na.rm=TRUE),0)) %>% 
  filter(FENCED != "Y_but_fence_down_since_2013") %>% 
  filter(SPECIES_CODE != "SAXX") %>% 
  ggplot(aes(yr, SPECIES_CODE)) +
  geom_tile(aes(fill=mean.max.ht),color = 'white') +
  scale_fill_viridis(option = "A") +
  geom_text(aes(label=mean.max.ht), color = 'white', size = 3.75) +
  theme_bw() +
  labs(title = "Maximum shrub height", subtitle = "Mean of shrub height pooled by fenced status", x = "Year", y = "Species", fill = "cm") +
  facet_wrap(~FENCED, ncol= 2)

# ggsave("./output/figures/maxShrubHy_by_spp_WC_heatmap_lbl.png", width = 6.5, height = 6.5, dpi = 300)

```


```{r, eval=FALSE}
# FIX NA for fenced
### Elk winter range by individual site
## tracking the individual SITE_ID
csv.all.lc.li.df %>% 
  mutate(yr = lubridate::year(DATE)) %>% 
  filter(!is.na(FENCED)) %>% 
  filter(!is.na(MAX_HEIGHT_CM)) %>%
  filter(FENCED != "Y_but_fence_down_since_2013") %>% 
  filter(SPECIES_CODE != "SAXX") %>%
  group_by(yr,SITE_TYPE, FENCED, SITE_ID, SPECIES_CODE) %>%
  filter(SITE_TYPE == "WC") %>% 
  group_by(yr,SITE_TYPE, FENCED, SPECIES_CODE) %>%
  ggplot(aes(yr, FENCED)) +
  geom_tile(aes(fill = MAX_HEIGHT_CM)) +
  # geom_text(aes(label = MAX_HEIGHT_CM)) +
  # facet_grid(SITE_ID~SPECIES_CODE)
  facet_wrap(~SITE_ID)
  scale_fill_viridis(option = "A") +
  geom_text(aes(label=mean.max.ht), color = 'white', size = 3.75) +
  theme_bw() +
  labs(title = "Maximum shrub height", subtitle = "Mean of shrub height pooled by fenced status", x = "Year", y = "Species", fill = "cm") +
  facet_wrap(~FENCED, ncol= 2)

```



```{r, echo=FALSE, eval = FALSE}

## theres a problem with the spatial join. MAny records without attributes like "FENCED"
# csv.all.lc.li.df %>% 
#   filter(is.na(LOCATION)) %>% 
#   View()

## core winter range
csv.all.lc.li.df %>% 
  filter(!is.na(MAX_HEIGHT_CM)) %>%
  # group_by(yr,SITE_TYPE, FENCED, SITE_ID, SPECIES_CODE) %>%
  filter(SITE_TYPE == "WC") %>% 
  filter(yr == 2008 | yr == 2013 | yr == 2018) %>% 
  filter(str_detect(SPECIES_CODE, "^SA")) %>%
  filter(SPECIES_CODE !="SAPE" & SPECIES_CODE !="SAWO" & SPECIES_CODE !="SAXX" & SPECIES_CODE !="SALUC" & SPECIES_CODE !="SABR"& SPECIES_CODE !="SAER") %>% 
  ggplot(aes(yr,MAX_HEIGHT_CM)) +
  geom_boxplot(aes(fill = LOCATION)) +
  # scale_fill_viridis(option = "A") +
    theme_bw() +
  labs(title = "Maximum shrub height", x = "Year", y = "Max shrub height (cm)") +
  facet_grid(FENCED~SPECIES_CODE)
  # facet_wrap(~SPECIES_CODE, ncol= 5)

# >Need to determine how to properly deal with "NA" and "Y_but_fence_down_since_2013" in "FENCED" field.

```

### All shrub species and years by type

```{r}
csv.all.lc.li.df %>% 
  filter(!is.na(MAX_HEIGHT_CM)) %>%
  filter(SPECIES_CODE != "SAXX") %>%
  filter(SPECIES_CODE != "NONE") %>%
  # names() %>% 
  group_by(yr,SITE_TYPE, SPECIES_CODE, MAX_HEIGHT_CM) %>%
  summarise(mean.max.ht = mean(MAX_HEIGHT_CM,na.rm=TRUE)) %>% 
  ggplot(aes(yr, SPECIES_CODE)) +
  geom_tile(aes(fill=MAX_HEIGHT_CM),color = 'white') +
  scale_fill_viridis(option = "C") +
  # theme_minimal() +
  theme_bw() +
  labs(title = "Maximum shrub height", x = "Year", y = "Species") +
  facet_wrap(~SITE_TYPE, ncol = 3) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))


```


SITE_TYPE: WC=Willow Core, WNC=Willow Noncore, WK=Willow Kawuneeche Valley

```{r}
csv.all.lc.li.df %>% 
  filter(!is.na(MAX_HEIGHT_CM)) %>%
  filter(str_detect(SPECIES_CODE, "^SA")) %>% 
  filter(SPECIES_CODE !="SAPE" & SPECIES_CODE !="SAWO" & SPECIES_CODE !="SAXX" & SPECIES_CODE !="SALUC" & SPECIES_CODE !="SABR"& SPECIES_CODE !="SAER") %>%
  # names() %>% 
  # group_by(yr,SITE_TYPE, SPECIES_CODE, MAX_HEIGHT_CM) %>%
  # summarise(mean.max.ht = mean(MAX_HEIGHT_CM,na.rm=TRUE)) %>% 
  ggplot(aes(yr, MAX_HEIGHT_CM)) +
  geom_boxplot(aes(fill=SITE_TYPE), color = 'black') +
  scale_fill_viridis(discrete = TRUE) +
  theme_minimal() +
  labs(title = "Maximum shrub height", x = "Year", y = "Species", subtitle = "Pooled data evaluated for the most commonly encounted willow spp. across transects") +
  # facet_wrap(~SPECIES_CODE, ncol = 5) +
  facet_grid(SITE_TYPE~SPECIES_CODE) +
  theme(axis.text.x=element_text(angle=45,hjust=1))
  # facet_grid(SPECIES_CODE~yr)


```

Note that because of panel design, different set of plots may be represented in different years.

_Salix moniticola_ 
```{r}

## Panel plot: Willow species
# csv.all.lc.li.df %>%
#   filter(yr !=2009 & yr != 2015 & yr !=2017) %>% 
#   filter(SPECIES_CODE == "SAMO") %>%   filter(!is.na(MAX_HEIGHT_CM)) %>%
#   filter(str_detect(SPECIES_CODE, "^SA")) %>% 
#   filter(SPECIES_CODE !="SAPE" & SPECIES_CODE !="SAWO" & SPECIES_CODE !="SAXX" & SPECIES_CODE !="SALUC" & SPECIES_CODE !="SABR"& SPECIES_CODE !="SAER") %>%
#   filter(str_detect(SPECIES_CODE, "^SA")) %>%
#   ggplot() +
#   ggridges::geom_density_ridges(aes(x = MAX_HEIGHT_CM, y =  yr, fill = SITE_TYPE), alpha = 0.45, ) +
#   viridis::scale_fill_viridis(discrete = TRUE, option = "D") +
#   theme_minimal() +
#   facet_wrap(~SITE_TYPE, ncol = 1) +
#   labs(x = "Max height (cm)", y = "Year", caption = "Salix monticola")


csv.all.lc.li.df %>%
  filter(yr !=2009 & yr != 2015 & yr !=2017) %>% 
  filter(SITE_TYPE != "WK") %>%
  filter(SPECIES_CODE == "SAMO") %>%   filter(!is.na(MAX_HEIGHT_CM)) %>%
  filter(str_detect(SPECIES_CODE, "^SA")) %>% 
  filter(SPECIES_CODE !="SAPE" & SPECIES_CODE !="SAWO" & SPECIES_CODE !="SAXX" & SPECIES_CODE !="SALUC" & SPECIES_CODE !="SABR"& SPECIES_CODE !="SAER") %>%
  filter(str_detect(SPECIES_CODE, "^SA")) %>%
  ggplot() +
  ggridges::geom_density_ridges(aes(x = MAX_HEIGHT_CM, y =  yr, fill = SITE_TYPE), alpha = 0.45, ) +
  viridis::scale_fill_viridis(discrete = TRUE, option = "D") +
  theme_minimal() +
  facet_wrap(~SITE_TYPE, ncol = 1) +
  labs(x = "Max height (cm)", y = "Year", caption = "SAMO") +
  coord_flip()

```

_Salix planifolia_

```{r}
## another species: SAPL
csv.all.lc.li.df %>%
  filter(yr !=2009 & yr != 2015 & yr !=2017) %>%
  # filter(yr == 2018) %>%
  # distinct(SPECIES_CODE)
  filter(SITE_TYPE == "WC") %>%
  # filter(SITE_TYPE != "WK") %>% # leave out KW
  # filter(SPECIES_CODE == "SAPL") %>%
  filter(SPECIES_CODE == "SAMO" | SPECIES_CODE == "SAGE") %>%
  filter(!is.na(MAX_HEIGHT_CM)) %>%
  filter(str_detect(SPECIES_CODE, "^SA")) %>% 
  filter(SPECIES_CODE !="SAPE" & SPECIES_CODE !="SAWO" & SPECIES_CODE !="SAXX" & SPECIES_CODE !="SALUC" & SPECIES_CODE !="SABR"& SPECIES_CODE !="SAER") %>%
  filter(str_detect(SPECIES_CODE, "^SA")) %>%
  ggplot() +
  ggridges::geom_density_ridges(aes(x = MAX_HEIGHT_CM, y =  yr, fill = FENCED), alpha = 0.45, ) +
  viridis::scale_fill_viridis(discrete = TRUE, option = "D") +
  theme_minimal() +
  # facet_wrap(~SITE_TYPE, ncol = 1) +
  facet_grid(SPECIES_CODE~SITE_TYPE) +
  labs(x = "Max height (cm)", y = "Year", caption = "Line intercept data")


```


```{r, eval=FALSE, fig.height=9, fig.width=8}

csv.all.lc.li.df %>% 
  filter(!is.na(MAX_HEIGHT_CM)) %>%
  filter(str_detect(SPECIES_CODE, "^SA")) %>% 
  filter(SPECIES_CODE !="SAPE" & SPECIES_CODE !="SAWO" & SPECIES_CODE !="SAXX" & SPECIES_CODE !="SALUC" & SPECIES_CODE !="SABR" & SPECIES_CODE !="SAER") %>%
  group_by(yr, SPECIES_CODE) %>% 
  summarise_if(is.numeric, median, na.rm = TRUE) %>% 
  ungroup() %>% 
  mutate(yr = as.character(yr)) %>% 
  mutate(yr = as.numeric(yr)) %>%
  ggplot(aes(x = yr, y = MAX_HEIGHT_CM)) +
  geom_point(aes(color = SPECIES_CODE))  +
  geom_line(aes(color = SPECIES_CODE))# +
  # geom_smooth(aes(color = SPECIES_CODE))

### Max shrub height

csv.all.lc.li.df %>% 
  filter(!is.na(MAX_HEIGHT_CM)) %>%
  filter(str_detect(SPECIES_CODE, "^SA")) %>% 
  filter(SPECIES_CODE !="SAPE" & SPECIES_CODE !="SAWO" & SPECIES_CODE !="SAXX" & SPECIES_CODE !="SALUC" & SPECIES_CODE !="SABR" & SPECIES_CODE !="SAER") %>%
  # names() %>% 
  # group_by(yr,SITE_TYPE, SPECIES_CODE, MAX_HEIGHT_CM) %>%
  # summarise(mean.max.ht = mean(MAX_HEIGHT_CM,na.rm=TRUE)) %>% 
  ggplot(aes(yr, MAX_HEIGHT_CM)) +
  geom_boxplot(aes(fill=SITE_TYPE), color = 'black') +
  scale_fill_viridis(discrete = TRUE) +
  # theme_minimal() +
  theme_bw() +
  labs(title = "Maximum shrub height by year, species and Site Type", x = "Year", y = "Species")+
  facet_wrap(~SPECIES_CODE, ncol = 3)# %>%
  # facet_grid(SPECIES_CODE~yr, scales = "free_x")

```



```{r}

csv.all.lc.li.df %>% 
  filter(!is.na(FENCED)) %>%
  filter(FENCED != "Y_but_fence_down_since_2013") %>%
  filter(yr != "2015" & yr != "2009" & yr != "" & yr != "2017") %>% 
  filter(!is.na(MAX_HEIGHT_CM)) %>%
  filter(str_detect(SPECIES_CODE, "^SA")) %>% 
  filter(SPECIES_CODE !="SAPE" & SPECIES_CODE !="SAWO" & SPECIES_CODE !="SAXX" & SPECIES_CODE !="SALUC" & SPECIES_CODE !="SABR" & SPECIES_CODE !="SAER") %>%
  filter(SITE_TYPE == "WC") %>% 
  ggplot(aes(yr, MAX_HEIGHT_CM)) +
  geom_boxplot(aes(fill=FENCED), color = 'black') +
  # scale_fill_viridis(discrete = TRUE) +
  # theme_minimal() +
  theme_bw() +
  labs(title = "Maximum shrub height by year, species and fencing", x = "Year", y = "Species")+
  # facet_wrap(~SPECIES_CODE, ncol = 3) %>%
  facet_grid(SPECIES_CODE~yr, scales = "free_x")

```

> Make assumption that "NA" for fenced is not fenced?

### Core winter range: fenced vs unfenced
```{r}
## will want to be sure interannual comparisons are made on using the right sets of points
## if, for example, 1/3 of 2018 plots were sampled in 2017, a comparison made on all of the 2018 data wouldn't make too much sense. 


# SAMO        
# SAPL        
# SAGE        
# SABE        
# SADR
##
# csv.all.lc.li.df %>% 
#   filter(!is.na(MAX_HEIGHT_CM)) %>%
#   filter(str_detect(SPECIES_CODE, "^SA")) %>% 
#   filter(FENCED == "N" | FENCED == "Y") %>% 
#   filter(SPECIES_CODE !="SAPE" & SPECIES_CODE !="SAWO" & SPECIES_CODE !="SAXX" & SPECIES_CODE !="SALUC" & SPECIES_CODE !="SABR" & SPECIES_CODE !="SAER") %>%
#   filter(SITE_TYPE == "WC") %>% 
#   ggplot(aes(yr, MAX_HEIGHT_CM)) +
#   geom_boxplot(aes(fill=FENCED), color = 'black') +
#   scale_fill_viridis(discrete = TRUE) +
#   # theme_minimal() +
#   theme_minimal() +
#   scale_fill_manual(values = c("ivory2","lightblue")) +
#   labs(x = "Year", y = "Max height (cm)", fill = "Fenced?", caption = "All plots and Salix species")
#   # labs(title = "Salix monticola maximum shrub height by year, fencing", x = "Year", y = "Species")

## all willow spp  
csv.all.lc.li.df %>% 
  filter(!is.na(MAX_HEIGHT_CM)) %>%
  filter(yr == 2008 | yr == 2013 | yr == 2018) %>% 
  filter(str_detect(SPECIES_CODE, "^SA")) %>% 
  filter(FENCED == "N" | FENCED == "Y") %>% 
  # filter(SPECIES_CODE !="SAPE" & SPECIES_CODE !="SAWO" & SPECIES_CODE !="SAXX" & SPECIES_CODE !="SALUC" & SPECIES_CODE !="SABR" & SPECIES_CODE !="SAER") %>%
  filter(SITE_TYPE == "WC") %>% 
  ggplot(aes(yr, MAX_HEIGHT_CM)) +
  geom_boxplot(aes(fill=FENCED), color = 'black', outlier.shape = NA) +
  # scale_fill_viridis(discrete = TRUE) +
  # theme_minimal() +
  theme_minimal() +
  ylim(0, 350) +
  scale_fill_manual(values = c("ivory2","lightblue")) +
  labs(x = "Year", y = "Max height (cm)", fill = "Fenced?", title = "Core Winter Range Plots: All Willow Species", caption = "Line intercept data")
  # labs(title = "Salix monticola maximum shrub height by year, fencing", x = "Year", y = "Species")

# ggsave("./output/figures/WC_all_willow_boxplot01.png", width = 6, height = 4.5, dpi= 300)

```

```{r, eval=TRUE}
## salix monitcola
csv.all.lc.li.df %>%
  filter(pType == "willow") %>% 
  filter(yr == 2008 | yr == 2013 | yr == 2018) %>%
  filter(!is.na(MAX_HEIGHT_CM)) %>%
  filter(str_detect(SPECIES_CODE, "^SA")) %>% 
  filter(FENCED == "N" | FENCED == "Y") %>% 
  # filter(SPECIES_CODE !="SAPE" & SPECIES_CODE !="SAWO" & SPECIES_CODE !="SAXX" & SPECIES_CODE !="SALUC" & SPECIES_CODE !="SABR" & SPECIES_CODE !="SAER") %>%
  # filter(SPECIES_CODE !="SAXX") %>% 
  filter(SPECIES_CODE =="SAMO") %>% 
  # distinct(SPECIES_CODE)
  filter(SITE_TYPE == "WC") %>% 
  ggplot(aes(yr, MAX_HEIGHT_CM)) +
  geom_boxplot(aes(fill=FENCED), color = 'black', outlier.shape = NA) +
  scale_fill_viridis(discrete = TRUE) +
  # theme_minimal() +
  theme_minimal() +
  ylim(0,320) +
  scale_fill_manual(values = c("ivory2","lightgreen")) +
  labs(x = "Year", y = "Max height (cm)", fill = "Fenced?") +
  labs(x = "Year", y = "Max height (cm)", fill = "Fenced?", title = "Core Winter Range Plots: SAMO only", caption = "Line intercept data")
  # labs(title = "Salix monticola maximum shrub height by year, fencing", x = "Year", y = "Species")

# ggsave("./output/figures/WC_willLI_SAMO_bxplt01.png", width = 6, height = 4.5, dpi= 300)

```

```{r}

## all shrub species
csv.all.lc.li.df %>%
  filter(pType == "willow") %>% 
  filter(yr == 2008 | yr == 2013 | yr == 2018) %>%
  filter(!is.na(MAX_HEIGHT_CM)) %>%
  # filter(str_detect(SPECIES_CODE, "^SA")) %>% 
  filter(FENCED == "N" | FENCED == "Y") %>% 
  # filter(SPECIES_CODE !="SAPE" & SPECIES_CODE !="SAWO" & SPECIES_CODE !="SAXX" & SPECIES_CODE !="SALUC" & SPECIES_CODE !="SABR" & SPECIES_CODE !="SAER") %>%
  # filter(SPECIES_CODE !="SAXX") %>% 
  # filter(SPECIES_CODE =="SAMO") %>% 
  # distinct(SPECIES_CODE)
  filter(SITE_TYPE == "WC") %>% 
  ggplot(aes(yr, MAX_HEIGHT_CM)) +
  geom_boxplot(aes(fill=FENCED), color = 'black', outlier.shape = NA) +
  scale_fill_viridis(discrete = TRUE) +
  # theme_minimal() +
  theme_minimal() +
  ylim(0,320) +
  scale_fill_manual(values = c("ivory2","slategray")) +
  # labs(x = "Year", y = "Max height (cm)", fill = "Fenced?") +
  labs(x = "Year", y = "Max height (cm)", fill = "Fenced?", title = "Core Winter Range Plots: All Shrub Species", caption = "Line intercept data")
  # labs(title = "Salix monticola maximum shrub height by year, fencing", x = "Year", y = "Species")

# ggsave("./output/figures/WC_willLI_allShrubSpp_bxplt01.png", width = 6, height = 4.5, dpi= 300)

```

```{r}
csv.all.lc.li.df %>%
  filter(pType == "willow") %>% 
  filter(SPECIES_CODE != "SAXX") %>% 
  filter(yr == 2008 | yr == 2013 | yr == 2018) %>%
  filter(!is.na(MAX_HEIGHT_CM)) %>%
  # filter(str_detect(SPECIES_CODE, "^SA")) %>%
  filter(FENCED == "N" | FENCED == "Y") %>% 
  group_by(yr, SPECIES_CODE, FENCED) %>% 
  # summarise(mean.ht = mean(MAX_HEIGHT_CM, na.rm = TRUE), sd.ht = sd(MAX_HEIGHT_CM, na.rm = TRUE)) %>%
  summarise(mean.ht = mean(MAX_HEIGHT_CM, na.rm = TRUE)) %>% 
  pivot_wider(names_from = yr, values_from = c(mean.ht)) %>% 
  gt::gt() %>% 
  fmt_number(
    columns = vars('2008','2013','2018'),
    decimals = 1,
    use_seps = FALSE
  ) %>% 
  tab_header("Mean height by shrub species")

```



```{r}

csv.all.lc.li.df %>%
  filter(pType == "willow") %>% 
  filter(SPECIES_CODE != "SAXX") %>% 
  filter(yr == 2008 | yr == 2013 | yr == 2018) %>%
  filter(!is.na(MAX_HEIGHT_CM)) %>%
  filter(str_detect(SPECIES_CODE, "^SA")) %>%
  filter(FENCED == "N" | FENCED == "Y") %>% 
  group_by(yr, FENCED) %>% 
  # summarise(mean.ht = mean(MAX_HEIGHT_CM, na.rm = TRUE), sd.ht = sd(MAX_HEIGHT_CM, na.rm = TRUE)) %>%
  summarise(mean.ht = mean(MAX_HEIGHT_CM, na.rm = TRUE)) %>% 
  pivot_wider(names_from = yr, values_from = c(mean.ht)) %>% 
  gt::gt() %>% 
  fmt_number(
    columns = vars('2008','2013','2018'),
    decimals = 1,
    use_seps = FALSE
  ) %>% 
  tab_header("Mean height (cm) by all willow species")

```


```{r, eval=FALSE}
# Maximum Core winter range sites, maximum shrub height by species, fencing treatment, and year in line interecept dataset.**

csv.all.lc.li.df %>% 
  filter(!is.na(MAX_HEIGHT_CM)) %>%
  filter(str_detect(SPECIES_CODE, "^SA")) %>% 
  filter(FENCED == "N" | FENCED == "Y") %>% 
  # filter(SPECIES_CODE !="SAPE" & SPECIES_CODE !="SAWO" & SPECIES_CODE !="SAXX" & SPECIES_CODE !="SALUC" & SPECIES_CODE !="SABR" & SPECIES_CODE !="SAER") %>%
  filter(SITE_TYPE == "WC") %>% 
  group_by(SPECIES_CODE,yr,FENCED) %>% 
  # View()
  dplyr::summarise(mean.max.ht = mean(MAX_HEIGHT_CM, na.rm = TRUE)) %>%
  ungroup() %>% 
  mutate(yr = as.character(yr)) %>% 
  mutate(yr = anytime::anytime(yr)) %>% 
  # mutate(yr = as.integer(yr)) %>% 
  ggplot(aes(x = yr, y = mean.max.ht)) +
  # geom_line(aes(color = FENCED)) +
  geom_smooth(aes(color = FENCED), method = "lm", se = FALSE, alpha = .5) +
  geom_point(aes(color = FENCED)) +
  # geom_boxplot(aes(fill=FENCED), color = 'black') +
  # scale_fill_viridis(discrete = TRUE) +
  # theme_minimal() +
  theme_bw() +
  # scale_fill_manual(values = c("ivory2","lightblue")) +
  labs(title = "Core winter range sites: maximum shrub height by year, fencing", x = "Year", y = "Height  (cm)") +
  facet_wrap(~SPECIES_CODE, ncol = 2)
  

```

**Core winter range sites, maximum shrub height by species, fencing treatment, and year in line interecept dataset.** 

```{r, eval = FALSE}
csv.all.lc.li.df %>% 
  filter(!is.na(MAX_HEIGHT_CM)) %>%
  # filter(str_detect(SPECIES_CODE, "^SA")) %>% 
  filter(FENCED == "N" | FENCED == "Y") %>% 
  filter(SPECIES_CODE !="SAPE" & SPECIES_CODE !="SAWO" & SPECIES_CODE !="SAXX" & SPECIES_CODE !="SALUC" & SPECIES_CODE !="SABR" & SPECIES_CODE !="SAER" | SPECIES_CODE !="ACGL" | SPECIES_CODE !="RUID") %>%
  filter(SITE_TYPE == "WC") %>%
  group_by(yr,FENCED, SPECIES_CODE) %>% 
  dplyr::summarise(mean.max.ht = mean(MAX_HEIGHT_CM, na.rm = TRUE), sd.max.ht = sd(MAX_HEIGHT_CM, na.rm=TRUE)) %>%
  ungroup() %>% 
  group_by(SPECIES_CODE) %>% 
  mutate(n.sp = n()) %>% 
  filter(n.sp > 5) %>% 
  ungroup() %>% 
  mutate(yr = as.character(yr)) %>% 
  mutate(yr = anytime::anytime(yr)) %>% 
  # mutate(yr = as.integer(yr)) %>% 
  ggplot(aes(x = yr, y = mean.max.ht)) +
  # geom_line(aes(color = FENCED)) +
  geom_smooth(aes(color = FENCED), method = "lm", se = FALSE) +
  geom_errorbar(aes(ymin = mean.max.ht - sd.max.ht, ymax = mean.max.ht + sd.max.ht, color = FENCED)) +
  geom_point(aes(color = FENCED),position="dodge") +
  # geom_boxplot(aes(fill=FENCED), color = 'black') +
  # scale_fill_viridis(discrete = TRUE) +
  # theme_minimal() +
  theme_bw() +
  labs(title = "Core winter range sites: maximum shrub height by year, fencing", x = "Year", y = "Height (cm)", subtitle = "Error bars represent +/- 1 SD, Trend line is a LM fit. Note scale of y axis varies between panels.") +
  facet_wrap(~SPECIES_CODE, ncol = 2, scales= 'free')

```


```{r, eval=FALSE}
## reclass the burned NA
csv.all.lc.li.df <- csv.all.lc.li.df %>% 
  mutate(BURNED = case_when(is.na(BURNED) ~ "Not burned",
                            TRUE ~ as.character(BURNED)))

csv.all.lc.li.df %>% 
  filter(BURNED != "BURNED") %>%
  filter(!is.na(MAX_HEIGHT_CM)) %>%
  filter(str_detect(SPECIES_CODE, "^SA")) %>%
  filter(SPECIES_CODE != "SAXX") %>%
  filter(yr == 2008 | yr == 2009 | yr == 2013 | yr == 2018) %>%
  filter(FENCED == "N" | FENCED == "Y") %>% 
  # filter(SPECIES_CODE !="SAPE" & SPECIES_CODE !="SAWO" & SPECIES_CODE !="SAXX" & SPECIES_CODE !="SALUC" & SPECIES_CODE !="SABR" & SPECIES_CODE !="SAER") %>%
  filter(SITE_TYPE == "WC") %>%
  # distinct(SPECIES_CODE) %>% 
  mutate(yr = as.character(yr)) %>% 
  mutate(yr = anytime::anytime(yr)) %>% 
  # mutate(yr = as.integer(yr)) %>% 
  ggplot(aes(x = yr, y = MAX_HEIGHT_CM)) +
  # geom_smooth(aes(color = FENCED), se = FALSE) +
  geom_smooth(aes(color = FENCED), method = "lm", se = FALSE) +
  geom_point(aes(color = FENCED, shape = FENCED)) +
  # geom_boxplot(aes(fill=FENCED), color = 'black') +
  # scale_fill_viridis(discrete = TRUE) +
  # theme_minimal() +
  theme_minimal() +
  # scale_fill_manual(values = c("ivory2","lightblue")) +
  labs(title = "Core winter range sites: maximum shrub height by year, fencing", x = "Year", color = "Fenced?", shape = "Fenced?", y = "Height (cm)", caption = "SAMO,SAPL, SAGE, SABE,SADR,SAPE,SAER")  +
  facet_wrap(~BURNED)

# ggsave("./output/figures/WC_Li_burned_v_unburned.png", width = 6.5, height = 4.5, dpi=300)

```

```{r}
csv.all.lc.li.df %>% 
  # distinct(BURNED) %>% 
  filter(BURNED != "BURNED") %>% 
  filter(!is.na(MAX_HEIGHT_CM)) %>%
  filter(str_detect(SPECIES_CODE, "^SA")) %>%
  filter(yr == 2008 | yr == 2013 | yr == 2018) %>%
  filter(FENCED == "N" | FENCED == "Y") %>% 
  filter(SPECIES_CODE != "SAXX") %>% 
  # filter(SPECIES_CODE !="SAPE" & SPECIES_CODE !="SAWO" & SPECIES_CODE !="SAXX" & SPECIES_CODE !="SALUC" & SPECIES_CODE !="SABR" & SPECIES_CODE !="SAER") %>%
  filter(SITE_TYPE == "WC") %>%
  # distinct(SPECIES_CODE) %>% 
  mutate(yr = as.character(yr)) %>% 
  mutate(yr = anytime::anytime(yr)) %>% 
  # mutate(yr = as.integer(yr)) %>% 
  ggplot(aes(x = yr, y = MAX_HEIGHT_CM)) +
  # geom_line(aes(color = FENCED)) +
  geom_smooth(aes(color = FENCED), method = "lm", se = FALSE) +
  geom_point(aes(color = FENCED, shape = FENCED)) +
  # geom_boxplot(aes(fill=FENCED), color = 'black') +
  # scale_fill_viridis(discrete = TRUE) +
  # theme_minimal() +
  theme_bw() +
  # scale_fill_manual(values = c("ivory2","lightblue")) +
  labs(title = "Core winter range sites: maximum shrub height by year, fencing", x = "Year", color = "Fenced?", shape = "Fenced?", y = "Height (cm)", caption = "SAMO,SAPL, SAGE, SABE,SADR,SAPE,SAER") 

```

```{r}

# burned faceted
csv.all.lc.li.df %>% 
  filter(BURNED != "BURNED") %>%
  filter(!is.na(MAX_HEIGHT_CM)) %>%
  filter(str_detect(SPECIES_CODE, "^SA")) %>%
  filter(SPECIES_CODE != "SAXX") %>%
  filter(yr == 2008 | yr == 2009 | yr == 2013 | yr == 2018) %>%
  filter(FENCED == "N" | FENCED == "Y") %>% 
  # filter(SPECIES_CODE !="SAPE" & SPECIES_CODE !="SAWO" & SPECIES_CODE !="SAXX" & SPECIES_CODE !="SALUC" & SPECIES_CODE !="SABR" & SPECIES_CODE !="SAER") %>%
  filter(SITE_TYPE == "WC") %>%
  # distinct(SPECIES_CODE) %>% 
  mutate(yr = as.character(yr)) %>% 
  mutate(yr = anytime::anytime(yr)) %>% 
  # mutate(yr = as.integer(yr)) %>% 
  ggplot(aes(x = yr, y = MAX_HEIGHT_CM)) +
  # geom_smooth(aes(color = FENCED), se = FALSE) +
  geom_smooth(aes(color = FENCED), method = "lm", se = FALSE) +
  geom_point(aes(color = FENCED, shape = FENCED)) +
  # geom_boxplot(aes(fill=FENCED), color = 'black') +
  # scale_fill_viridis(discrete = TRUE) +
  # theme_minimal() +
  theme_minimal() +
  # scale_fill_manual(values = c("ivory2","lightblue")) +
  labs(title = "Core winter range sites: maximum shrub height by year, fencing", x = "Year", color = "Fenced?", shape = "Fenced?", y = "Height (cm)", caption = "SAMO,SAPL, SAGE, SABE,SADR,SAPE,SAER")  +
  facet_grid(~BURNED)
facet_wrap(~BURNED)

```

### shrub height - LI

```{r}
## shrub height
csv.all.lc.li.df %>% 
  filter(BURNED != "BURNED") %>%
  filter(!is.na(MAX_HEIGHT_CM)) %>%
  filter(str_detect(SPECIES_CODE, "^SA")) %>%
  filter(SPECIES_CODE != "SAXX") %>%
  filter(yr == 2008 | yr == 2009 | yr == 2013 | yr == 2018) %>%
  filter(FENCED == "N" | FENCED == "Y") %>% 
  # filter(SPECIES_CODE !="SAPE" & SPECIES_CODE !="SAWO" & SPECIES_CODE !="SAXX" & SPECIES_CODE !="SALUC" & SPECIES_CODE !="SABR" & SPECIES_CODE !="SAER") %>%
  filter(SITE_TYPE == "WC") %>%
  # distinct(SPECIES_CODE) %>% 
  mutate(yr = as.character(yr)) %>% 
  # mutate(yr = anytime::anytime(yr)) %>% 
  group_by(FENCED, valley_full,pType, yr) %>% 
  summarise(mean.MAX_HEIGHT_CM = mean(MAX_HEIGHT_CM, na.rm = TRUE)) %>% 
  gt::gt()

```


#### Statistical comparisons: willow height

```{r}
#### Repeated measures: willow height

```


```{r}

# library(rstatix)



```


## Willow macroplot data


```{r}
# calculate the average canopy diameter
csv.all.lc.mcro.df <- csv.all.lc.mcro.df %>% 
  mutate(CANOPY_DIAM_AVG = (CANOPY_DIA_1_CM + CANOPY_DIA_2_CM)/2) 

### canopy diameter by species
mcro.canopy.diam.sum <- csv.all.lc.mcro.df %>%
  group_by(SITE_ID, yr, SPECIES_CODE, valley_full, FENCED) %>% 
  summarise(cano_diam_med = median(CANOPY_DIAM_AVG)) 

# mcro.canopy.diam.sum %>%
#   ungroup() %>% 
#   ggplot(aes(yr, cano_ht_med)) + 
#   geom_line(aes(color = SPECIES_CODE)) +
#   facet_grid(FENCED~valley_full)
  
```

```{r}
csv.all.lc.mcro.df <- csv.all.lc.mcro.df %>% 
  mutate(timeClass = case_when(yr == 2008 ~ "BL",
                              yr == 2009 ~ "BL", 
                              TRUE ~ as.character(yr))) %>% 
  mutate(timeClass = as.factor(timeClass)) %>% 
  mutate(timeClass = fct_relevel(timeClass, "2018", "2013", "BL"))

```

```{r}
## cleaning the LOCATION tab
csv.all.lc.mcro.df <- csv.all.lc.mcro.df %>%
  mutate(LOCATION = case_when(is.na(LOCATION) & SITE_TYPE == "WK" ~ "Kawuneeche",
                              TRUE ~ LOCATION))%>%
  mutate(LOCATION = str_replace(LOCATION, "_", " ")) %>%
  mutate(LOCATION = str_replace(LOCATION, "_", " ")) 
```

#### Beaver and Moose Presence in 2018
```{r beaver18, eval=FALSE}

#### Observations of beaver presence noted in plots 
# How best to use these obserations? 
# 
# **Variable: BEAVER_PRESENCE**

sinfo.df %>%
  mutate(BEAVER_PRESENCE = recode(BEAVER_PRESENCE, 
                         "Absence_" = "Absence",
                         "Food_cache_cuttings"="Cuttings")) %>% 
  tabyl(BEAVER_PRESENCE) %>% 
  gt::gt() %>% 
  fmt_number(
    columns = vars(percent),
    decimals = 2
    )

sinfo.df %>%
  mutate(BEAVER_PRESENCE = recode(BEAVER_PRESENCE, 
                         "Absence_" = "Absence",
                         "Food_cache_cuttings"="Cuttings")) %>%
  group_by(BEAVER_PRESENCE) %>%
  tally()

bv.tally <- sinfo.df %>%
  mutate(LOCATION = case_when(is.na(LOCATION) & SITE_TYPE == "WK" ~ "Kawuneeche",
                              TRUE ~ LOCATION))%>%
  mutate(LOCATION = str_replace(LOCATION, "_", " ")) %>%
  mutate(LOCATION = str_replace(LOCATION, "_", " ")) %>% 
  mutate(BEAVER_PRESENCE = recode(BEAVER_PRESENCE, 
                         "Absence_" = "Absence",
                         "Food_cache_cuttings"="Cuttings")) %>%
  group_by(LOCATION) %>% 
  mutate(n_site = n()) %>% 
  ungroup()

bv.tally %>% 
  group_by(LOCATION, BEAVER_PRESENCE, n_site) %>%
  tally() %>% 
  ggplot(aes(x = reorder(LOCATION, n_site), y = n)) +
  geom_col(aes(fill = BEAVER_PRESENCE)) +
  coord_flip() +
  labs(x = "", y = "Number of plots", fill = "", caption = "2018 Beaver presence") +
  scale_fill_manual(values = c("ivory3", "cyan3")) +
  theme_minimal()

ggsave("./output/figures_exported/beaver_presence01.png", width = 6.25, height = 3.75, dpi=300)

  
bv.tally %>% 
  group_by(LOCATION, BEAVER_PRESENCE, n_site) %>%
  tally() %>% 
  ungroup() %>% 
  mutate(perc.cut = n/n_site*100) %>% 
  filter(BEAVER_PRESENCE == "Cuttings")

```

```{r}
#vtree status

sinfo.df %>%
  mutate(BEAVER_PRESENCE = recode(BEAVER_PRESENCE, 
                         "Absence_" = "Absence",
                         "Food_cache_cuttings"="Cuttings")) %>% 
  vtree::vtree(z = .,vars = "LOCATION BEAVER_PRESENCE")
  

```

```{r}
sinfo.df %>%
  filter(LOCATION == "Moraine_Park") %>% 
  mutate(BEAVER_PRESENCE = recode(BEAVER_PRESENCE, 
                         "Absence_" = "Absence",
                         "Food_cache_cuttings"="Cuttings")) %>% 
  vtree::vtree(z = .,vars = "LOCATION FENCED BURNED")
```

```{r}
bv.mcro <- csv.all.lc.mcro.df %>% 
  mutate(BEAVER_PRESENCE = recode(BEAVER_PRESENCE, 
                         "Absence_" = "Absence",
                         "Food_cache_cuttings"="Cuttings")) 

bv.mcro %>% 
  distinct(BEAVER_PRESENCE)

bv.mcro.sum <- bv.mcro %>% 
  select(SITE_ID, timeClass,BEAVER_PRESENCE,LOCATION, SITE_TYPE) %>%
  distinct() %>% 
  group_by(timeClass,BEAVER_PRESENCE, SITE_TYPE) %>%
  tally() %>% 
  ungroup() %>% 
  pivot_wider(names_from = BEAVER_PRESENCE, values_from = n) %>%
  mutate(perc.cuttings = 100* Cuttings/(Cuttings + Absence)) %>% 
  mutate(perc.abs = 100 - perc.cuttings)

bv.mcro.sum %>%
  filter(timeClass == "BL" | timeClass == "2013" | timeClass == "2018") %>%
  arrange(desc(SITE_TYPE,timeClass)) %>% 
  gt()
  

```


```{r}

# sinfo.df %>% 
#   distinct(MOOSE_PRESENCE)

# inconsistent encoding of MOOSE_PRESENCE 

# # A tibble: 10 x 1
#    MOOSE_PRESENCE             
#    <chr>                      
#  1 Absence_                   
#  2 Browse                     
#  3 Browse/Tracks              
#  4 Browse_tracks              
#  5 Tracks                     
#  6 Scat_beds_                 
#  7 Browse_scat_tracks         
#  8 Browse_scat                
#  9 Scat                       
# 10 Browse_scat_tracks_sighting

sinfo.df <- sinfo.df %>%
  mutate(MOOSE_PRESENCE2 = recode(MOOSE_PRESENCE, 
                         "Absence_" = "Absence",
                         "Browse_tracks"="Presence",
                         "Browse/Tracks"="Presence",
                         "Browse_scat"="Presence",
                         "Browse_scat_tracks"="Presence",
                         "Browse_scat_tracks_sighting" = "Presence",
                         "Scat_beds_" = "Presence"
                         )) %>% 
  mutate(MOOSE_PRESENCE = recode(MOOSE_PRESENCE, 
                         "Absence_" = "Absence",
                         "Browse_tracks"="Browse/tracks",
                         "Browse/Tracks"="Browse/tracks",
                         "Browse_scat"="Browse/scat",
                         "Browse_scat_tracks"="Browse/scat/tracks",
                         "Browse_scat_tracks_sighting" = "Browse/scat/tracks/sighting",
                         "Scat_beds_" = "Scat/beds"
                         )) 

sinfo.df %>% 
  tabyl(MOOSE_PRESENCE) %>%
  rename('Moose presence' = 'MOOSE_PRESENCE') %>% 
  gt::gt() %>% 
  fmt_number(
    columns = vars(percent),
    decimals = 2
    ) %>% 
  tab_header(
    title = "Moose presence in 2018"
  )

# sinfo.df %>%
#   tabyl(MOOSE_PRESENCE2) %>%
#   rename('Moose presence' = 'MOOSE_PRESENCE2') %>% 
#   gt::gt() %>% 
#   fmt_number(
#     columns = vars(percent),
#     decimals = 2
#     ) %>% 
#   tab_header(
#     title = "Moose presence in 2018"
#   )

```


```{r Moose, eval=TRUE}
#### Observations of moose presence noted in plots
# > How best to use these obserations? 
# **Variable: MOOSE_PRESENCE**


mcro.moose <- csv.all.lc.mcro.df %>% 
  mutate(moose = case_when(MOOSE_PRESENCE == "Absence_" ~ "Absent",
                           MOOSE_PRESENCE != "Absent" ~ "Present",
                           TRUE ~ MOOSE_PRESENCE))

mcro.moose.tally <- mcro.moose %>% 
  select(c(SITE_ID, moose, yr, LOCATION, BURNED, FENCED, timeClass)) %>% 
  distinct() %>% 
  group_by(timeClass, LOCATION) %>% 
  mutate(n_plots_in_loc = n()) %>% 
  ungroup() 

mcro.moose.tally <- mcro.moose.tally %>%
  filter(!is.na(LOCATION)) %>%
  group_by(timeClass, moose, LOCATION, n_plots_in_loc) %>% 
  # mutate(n_plots_in_loc_sign = n()) %>% 
  tally() %>%
  ungroup() %>%
  mutate(perc_moose = n/n_plots_in_loc * 100) 

mcro.moose.tally.n <- mcro.moose.tally %>% 
  group_by(timeClass, moose, LOCATION) %>%
  tally() %>% 
  ungroup()
```

```{r}
## moose plotting
mcro.moose.tally %>%
  filter(timeClass == "BL" | timeClass == "2013" | timeClass == "2018") %>% 
  filter(LOCATION != "Kawuneeche") %>% 
  mutate(timeClass = forcats::fct_rev(timeClass)) %>%
  ggplot(aes(x = timeClass, y = perc_moose)) +
  geom_col(aes(fill = moose), width = .7) +
  facet_wrap(~LOCATION, ncol = 3) +
  theme_minimal() +
  labs(x = "", y = "% plots", fill = "") +
  scale_fill_manual(values = c("ivory3", "cyan3"))

# ggsave("./output/figures_exported/moose_presence_absence01.png", width = 6.25, height = 3.75, dpi=300)

mcro.moose.tally %>%
  filter(timeClass == "BL" | timeClass == "2013" | timeClass == "2018") %>% 
  filter(LOCATION != "Kawuneeche") %>% 
  filter(moose =="Present") %>% 
  mutate(timeClass = forcats::fct_rev(timeClass))%>%
  ggplot(aes(x = timeClass, y = perc_moose)) +
  geom_col(aes(fill = moose), width = 0.7) +
  facet_wrap(~LOCATION, ncol = 3) +
  theme_minimal() +
  labs(x = "", y = "% plots", fill = "") +
  scale_fill_manual(values = c("ivory4", "blue")) +
  theme(legend.position = "none") 
  
# ggsave("./output/figures_exported/moose_presence01.png", width = 6.25, height = 3.75, dpi=300)

mcro.moose.tally %>%
  filter(timeClass == "BL" | timeClass == "2013" | timeClass == "2018") %>%
  datatable()


csv.all.lc.mcro.df %>% 
  # distinct(MOOSE_PRESENCE)
  group_by(SITE_ID, MOOSE_PRESENCE, yr) %>% 
  filter(MOOSE_PRESENCE != "Absence_") %>%
  tally() %>% 
  dplyr::select(-n) %>% 
  datatable()

```

```{r}

# fun.desc.post1.gt(kv.stmod_stmcnt1) %>% 
#   gt::gtsave(filename = "./output/tables/AK_kv.stmod_stmcnt1_posteriors.rtf")

```


----

```{r, eval=FALSE}

# csv.all.lc %>% View()

# unnest to get at field names
# across all csv files
csv.all.lc %>% 
  unnest(field_names) %>% 
  distinct(ffname,field_names) %>% 
  datatable()


```


```{r}

csv.all.lc.mcro %>% 
  unnest(field_names) %>% 
  distinct(file_name_abr,field_names) %>% 
  # write_csv("output/temp_4_review/macroplot_fld_names.csv")
  datatable(rownames = FALSE, caption = "Macroplot inventory variable names.")


```



#### Canopy Diameter

Canopy diameter measurements from macroplots. Calculated as the mean of CANOPY_DIA_1_CM + CANOPY_DIA_2_CM. 

```{r, eval=TRUE}
## average the canopy
csv.all.lc.mcro.df <- csv.all.lc.mcro.df %>% 
  # names() %>% 
  mutate(CANOPY_DIA_CM_avg = (CANOPY_DIA_1_CM + CANOPY_DIA_2_CM)/2)

## clean up
csv.all.lc.mcro.df <- csv.all.lc.mcro.df %>% 
  mutate(FENCED = case_when(FENCED == "Y_but_fence_down_since_2013" ~ "Unfenced",
                             FENCED == "Y" ~ "Fenced",
                             FENCED == "N" ~ "Unfenced"))
```

```{r, eval=TRUE}

# **Summary table of canopy diameter by species **
csv.all.lc.mcro.df %>% 
  filter(str_detect(SPECIES_CODE, "^SA")) %>% 
  filter(SPECIES_CODE !="SAPE" & SPECIES_CODE !="SAWO" & SPECIES_CODE !="SAXX" & SPECIES_CODE !="SALUC" & SPECIES_CODE !="SABR" & SPECIES_CODE !="SABO" & SPECIES_CODE !="SAER" & SPECIES_CODE !="SABE" & SPECIES_CODE !="SADR" & SPECIES_CODE !="SALA") %>%
  filter(SITE_TYPE == "WC") %>%
  # filter(SITE_TYPE != "WNC") %>% 
  mutate(yr = as.character(yr)) %>%
  # mutate(yr = as.integer(yr)) %>%
  # mutate(yr = as.character(yr)) %>% 
  # filter(yr == 2013 | yr == 2018) %>%
  filter(timeClass == "BL" | timeClass == "2013" | timeClass == "2018") %>%
  mutate(timeClass = forcats::fct_rev(timeClass)) %>%   
  group_by(timeClass,SPECIES_CODE) %>% 
  skimr::skim(CANOPY_DIA_CM_avg) %>% 
  # names()
  # select(-c(formatted, level)) %>% 
  select(timeClass, contains("skim"),SPECIES_CODE, contains("c.m"), contains("c.s")) %>%
  select(-skim_type) %>% 
  ggplot(aes(timeClass, SPECIES_CODE)) +
  geom_tile(aes(fill = numeric.mean)) +
  geom_text(aes(label = round(numeric.mean,1)), color = "white") +
  # scale_fill_viridis(direction = -1) +
  scale_fill_gradient(low = "grey70", high = "grey20") +
  labs(x = "Year", y = "Species", fill = "Diameter (cm)", caption = "Mean Canopy Diameter - Core Range") +
  theme_minimal()

# ggsave("./output/figures_exported/WC_canopy_diamter_domSpp.png", width = 5.25, height = 3.55, dpi=300)

## non core
csv.all.lc.mcro.df %>% 
  filter(str_detect(SPECIES_CODE, "^SA")) %>% 
  filter(SPECIES_CODE !="SAPE" & SPECIES_CODE !="SAWO" & SPECIES_CODE !="SAXX" & SPECIES_CODE !="SALUC" & SPECIES_CODE !="SABR" & SPECIES_CODE !="SABO" & SPECIES_CODE !="SAER" & SPECIES_CODE !="SABE" & SPECIES_CODE !="SADR" & SPECIES_CODE !="SALA") %>%
  filter(SITE_TYPE == "WNC") %>%
  # filter(SITE_TYPE != "WNC") %>% 
  mutate(yr = as.character(yr)) %>%
  filter(timeClass == "BL" | timeClass == "2013" | timeClass == "2018") %>%
  mutate(timeClass = forcats::fct_rev(timeClass)) %>%   
  group_by(timeClass,SPECIES_CODE) %>% 
  skimr::skim(CANOPY_DIA_CM_avg) %>% 
  # names()
  # select(-c(formatted, level)) %>% 
  select(timeClass, contains("skim"),SPECIES_CODE, contains("c.m"), contains("c.s")) %>%
  select(-skim_type) %>% 
  ggplot(aes(timeClass, SPECIES_CODE)) +
  geom_tile(aes(fill = numeric.mean)) +
  geom_text(aes(label = round(numeric.mean,1)), color = "white") +
  # scale_fill_viridis(direction = -1) +
  scale_fill_gradient(low = "grey70", high = "grey20") +
  labs(x = "Year", y = "Species", fill = "Diameter (cm)", caption = "Mean Canopy Diameter - NonCore Range") +
  theme_minimal()

# ggsave("./output/figures_exported/WNC_canopy_diamter_domSpp.png", width = 5.25, height = 3.55, dpi=300)

```

#### Calculate cover
```{r}
canopy.all.spp <- csv.all.lc.mcro.df %>%
  mutate(PERCENT_PLANT_IN_PLOT = as.numeric(PERCENT_PLANT_IN_PLOT)/100) %>% 
  mutate(PERCENT_PLANT_IN_PLOT = case_when(is.na(PERCENT_PLANT_IN_PLOT) ~ 1,
         TRUE ~ PERCENT_PLANT_IN_PLOT)) %>%
  mutate(PERCENT_PLANT_IN_PLOT = case_when(PERCENT_PLANT_IN_PLOT == 1.45 ~ .145,
         TRUE ~ PERCENT_PLANT_IN_PLOT)) %>% # correct error in raw data
  mutate(cano.area.m2 = PERCENT_PLANT_IN_PLOT   * (CANOPY_DIA_CM_avg/2)^2 * 3.141593 * 0.0001)

canopy.all.spp <- canopy.all.spp %>% 
  mutate(cover.plant = cano.area.m2/16 * 100) %>% 
  mutate(cover.plant = case_when(cover.plant > 100 ~ 100,
                           TRUE ~ cover.plant))
## sum by species and calculate cover
canopy.all.spp.sum <- canopy.all.spp %>%
  group_by(timeClass, SITE_ID, SPECIES_CODE, SITE_TYPE, LOCATION, FENCED, BURNED) %>% 
  dplyr::summarise(cano.sppsum.m2 = sum(cano.area.m2)) %>% 
  mutate(cover.spp = cano.sppsum.m2/16*100) %>% 
  mutate(cover.spp = case_when(cover.spp > 100 ~ 100,
                               TRUE ~ cover.spp)) %>% 
  ungroup()

### calculate the sum and % cover for all willows combined
canopy.all.willow.sum <- canopy.all.spp %>%
  filter(str_detect(SPECIES_CODE, "^SA")) %>% 
  group_by(timeClass, SITE_ID, SITE_TYPE, LOCATION, FENCED, BURNED) %>% 
  dplyr::summarise(cano.sum.m2 = sum(cano.area.m2)) %>% 
  mutate(cover.allwillow = cano.sum.m2/16*100) %>% 
  mutate(cover.allwillow = case_when(cover.allwillow > 100 ~ 100,
                               TRUE ~ cover.allwillow)) %>% 
  ungroup()

```

```{r}
## write to csv
# canopy.all.willow.sum %>% 
#   write_csv("./output/exported_data/willow_cover_20200706.csv")

```


#### Plot and describe cover for all willow spp

**WC**
```{r}
canopy.all.willow.sum %>% 
  group_by(timeClass, SITE_TYPE) %>% 
  descr(cover.allwillow) %>% 
  summarytools::tb() %>% 
  datatable(filter = "top")

## Filter to just 5 yr resample and WC
canopy.all.willow.sum %>% 
  mutate(timeClass = forcats::fct_rev(timeClass)) %>%
  filter(SITE_TYPE == "WC") %>% 
  filter(timeClass == "BL" | timeClass == "2013" | timeClass == "2018") %>% 
  ggplot(aes(timeClass, cover.allwillow)) +
  geom_boxplot(fill = "ivory2") +
  facet_wrap(~FENCED) +
  labs(caption = "WC all willows combined macroplot cover", y = "% cover", x = "") +
  theme_minimal()

# ggsave("./output/figures_exported/cover_wc_boxplot01.png", width = 6.25, height = 3.75, dpi=300)
# ggsave("./output/figures_exported/cover_wc_boxplot01.pdf", width = 6.25, height = 3.75)

## create summary table
canopy.all.willow.sum %>% 
  mutate(timeClass = forcats::fct_rev(timeClass)) %>%
  filter(SITE_TYPE == "WC") %>% 
  filter(timeClass == "BL" | timeClass == "2013" | timeClass == "2018") %>% 
  group_by(timeClass, SITE_TYPE, FENCED) %>% 
  summarytools::descr(cover.allwillow) %>% 
  summarytools::tb() %>% 
  select(1,3,5:13, n.valid) %>% 
  gt()

```

```{r}
## WNC
## Filter to just 5 yr resample and WC
canopy.all.willow.sum %>% 
  mutate(timeClass = forcats::fct_rev(timeClass)) %>%
  filter(SITE_TYPE == "WNC") %>% 
  filter(timeClass == "BL" | timeClass == "2013" | timeClass == "2018") %>% 
  ggplot(aes(timeClass, cover.allwillow)) +
  geom_boxplot(fill = "ivory2") +
  # facet_wrap(~FENCED) +
  labs(caption = "WNC all willows combined macroplot cover", y = "% cover", x = "") +
  theme_minimal()

# ggsave("./output/figures_exported/cover_wnc_boxplot01.png", width = 3.75, height = 3.75, dpi=300)
# ggsave("./output/figures_exported/cover_wnc_boxplot01.pdf", width = 3.75, height = 3.75)

## create summary table
canopy.all.willow.sum %>% 
  mutate(timeClass = forcats::fct_rev(timeClass)) %>%
  filter(SITE_TYPE == "WNC") %>% 
  filter(timeClass == "BL" | timeClass == "2013" | timeClass == "2018") %>% 
  group_by(timeClass, SITE_TYPE, FENCED) %>% 
  summarytools::descr(cover.allwillow) %>% 
  summarytools::tb() %>% 
  select(1,3,5:13, n.valid) %>% 
  gt()
```


```{r, eval=FALSE}

csv.all.lc.mcro.df %>%
  # filter(yr == "2009" | yr == "2013") %>% 
    filter(str_detect(SPECIES_CODE, "^SA")) %>% 
  filter(SPECIES_CODE !="SAPE" & SPECIES_CODE !="SAWO" & SPECIES_CODE !="SAXX" & SPECIES_CODE !="SALUC" & SPECIES_CODE !="SABR" & SPECIES_CODE !="SAER") %>% 
  mutate(yr = as.factor(yr)) %>% 
  ggplot(aes(yr, CANOPY_DIA_CM_avg)) +
  geom_jitter() +
  facet_grid(SPECIES_CODE~SITE_TYPE) +
  theme_bw()

```

```{r, fig.width=6, fig.align = 'center', fig.height=9}
csv.all.lc.mcro.df %>%
  # filter(yr == "2009" | yr == "2013") %>% 
  filter(str_detect(SPECIES_CODE, "^SA")) %>% 
  filter(SITE_TYPE == "WC") %>% 
  filter(SPECIES_CODE !="SAPE" & SPECIES_CODE !="SAWO" & SPECIES_CODE !="SAXX" & SPECIES_CODE !="SALUC" & SPECIES_CODE !="SABR" & SPECIES_CODE !="SAER" & SPECIES_CODE !="SALE" & SPECIES_CODE !="SALU") %>% 
  mutate(yr = as.factor(yr)) %>% 
  ggplot(aes(yr, CANOPY_DIA_CM_avg)) +
  geom_boxplot(color="black", fill = "ivory2") +
  geom_jitter(alpha=.1, color="blue") +
  facet_grid(SPECIES_CODE~SITE_TYPE, scales = "free_y") +
  theme_bw() +
  labs(title = "Core Elk Winter Range Canopy Width", y = "Canopy height (cm)")

```


```{r}
### core winter range
### by species

csv.all.lc.mcro.df %>%
  filter(FENCED == "N" | FENCED == "Y") %>% 
  filter(yr == "2008" | yr == "2013" | yr == "2018") %>%
  filter(str_detect(SPECIES_CODE, "^SA")) %>% 
  filter(SITE_TYPE == "WC") %>% 
  filter(SPECIES_CODE !="SAPE" & SPECIES_CODE !="SAWO" & SPECIES_CODE !="SAXX" & SPECIES_CODE !="SALUC" & SPECIES_CODE !="SABR" & SPECIES_CODE !="SAER" & SPECIES_CODE !="SALE" & SPECIES_CODE !="SALU" & SPECIES_CODE !="SALA"& SPECIES_CODE !="SABO") %>% 
  # mutate(yr = factor(yr)) %>%
  group_by(SPECIES_CODE,yr) %>% 
  mutate(med.canopydiam = median(CANOPY_DIA_CM_avg)) %>%
  mutate(ptile = ntile(CANOPY_DIA_CM_avg,n = 100)) %>%
  ungroup() %>% 
  # mutate(q3.canopydiam = quatmedian(CANOPY_DIA_CM_avg))
  ggplot(aes(FENCED, CANOPY_DIA_CM_avg)) +
  # geom_point(aes(y = CANOPY_DIA_CM_avg, color = FENCED)) +
  geom_boxplot() +
  geom_jitter(aes(y = CANOPY_DIA_CM_avg, color = FENCED), alpha = .5) +
  # geom_point(aes(y = med.canopydiam),color = "black", shape = 3, size = 5) +
  # geom_smooth(aes(x = )) +
  facet_grid(SPECIES_CODE~yr, scales = "free_y") +
  theme_bw() +
  labs(title = "Core Elk Winter Range Canopy Width", x = "Fenced", y = "Canopy diameter (cm)") 
  # labs(title = "Core Elk Winter Range Canopy Width", subtitle = "The black '+' indicates median value for group", x = "Fenced", y = "Canopy height (cm)")

```

```{r, eval = FALSE}

# The medians aren;t right. they seem to just be for the species/yr, not spp yr fenced
csv.all.lc.mcro.df %>%
  filter(FENCED == "N" | FENCED == "Y") %>% 
  filter(yr == "2008" | yr == "2013" | yr == "2018") %>%
  filter(str_detect(SPECIES_CODE, "^SA")) %>% 
  filter(SITE_TYPE == "WC") %>% 
  filter(SPECIES_CODE !="SAPE" & SPECIES_CODE !="SAWO" & SPECIES_CODE !="SAXX" & SPECIES_CODE !="SALUC" & SPECIES_CODE !="SABR" & SPECIES_CODE !="SAER" & SPECIES_CODE !="SALE" & SPECIES_CODE !="SALU" & SPECIES_CODE !="SALA"& SPECIES_CODE !="SABO") %>% 
  # mutate(yr = factor(yr)) %>%
  group_by(SPECIES_CODE,yr) %>% 
  mutate(med.canopydiam = median(CANOPY_DIA_CM_avg)) %>%
  mutate(ptile = ntile(CANOPY_DIA_CM_avg,n = 100)) %>%
  ungroup() %>% 
  # mutate(q3.canopydiam = quatmedian(CANOPY_DIA_CM_avg))
  ggplot(aes(FENCED, CANOPY_DIA_CM_avg)) +
  # geom_point(aes(y = CANOPY_DIA_CM_avg, color = FENCED)) +
  # geom_jitter(aes(y = CANOPY_DIA_CM_avg, color = FENCED)) +
  geom_point(aes(y = med.canopydiam),color = "black", shape = 3, size = 5) +
  # geom_smooth(aes(x = )) +
  facet_grid(SPECIES_CODE~yr, scales = "free_y") +
  theme_bw() +
  labs(title = "Core Elk Winter Range Canopy Width", subtitle = "The black '+' indicates median value for group", x = "Fenced", y = "Canopy height (cm)")


```


```{r}

```




### Shrub Height - Macroplot

```{r}

csv.all.lc.mcro.df %>% 
  filter(str_detect(SPECIES_CODE, "^SA")) %>% 
  filter(SPECIES_CODE !="SAPE" & SPECIES_CODE !="SAWO" & SPECIES_CODE !="SAXX" & SPECIES_CODE !="SALUC" & SPECIES_CODE !="SABR" & SPECIES_CODE !="SABO" & SPECIES_CODE !="SAER") %>%
  filter(SITE_TYPE == "WC") %>%
  # filter(SITE_TYPE != "WNC") %>% 
  mutate(yr = as.character(yr)) %>%
  # mutate(yr = as.integer(yr)) %>%
  # mutate(yr = as.character(yr)) %>% 
  # filter(yr == 2013 | yr == 2018) %>%
  filter(yr == 2008 | yr == 2013 | yr == 2018) %>%
  group_by(yr,SPECIES_CODE) %>% 
  skimr::skim(PLANT_HT_CM) %>% 
  # names()
  # select(-c(formatted, level)) %>% 
  select(yr, contains("skim"),SPECIES_CODE, contains("c.m"), contains("c.s")) %>%
  select(-skim_type) %>% 
  ggplot(aes(yr, SPECIES_CODE)) +
  geom_tile(aes(fill = numeric.mean)) +
  geom_text(aes(label = round(numeric.mean,1)), color = "white") +
  scale_fill_viridis() +
  labs(x = "Year", y = "Species", fill = "mean", title = "Mean Height - Core Range", subtitle = "Macroplot data")

```

```{r}
csv.all.lc.mcro.df %>% 
  filter(str_detect(SPECIES_CODE, "^SA")) %>% 
  filter(SPECIES_CODE !="SAPE" & SPECIES_CODE !="SAWO" & SPECIES_CODE !="SAXX" & SPECIES_CODE !="SALUC" & SPECIES_CODE !="SABR" & SPECIES_CODE !="SABO" & SPECIES_CODE !="SAER") %>%
  filter(SITE_TYPE == "WC") %>%
  # filter(SITE_TYPE != "WNC") %>% 
  mutate(yr = as.character(yr)) %>%
  # mutate(yr = as.integer(yr)) %>%
  # mutate(yr = as.character(yr)) %>% 
  # filter(yr == 2013 | yr == 2018) %>%
  filter(yr == 2008 | yr == 2013 | yr == 2018) %>%
  group_by(yr,SPECIES_CODE, FENCED) %>% 
  skimr::skim(PLANT_HT_CM) %>% 
  # names()
  # select(-c(formatted, level)) %>% 
  select(yr, contains("skim"),SPECIES_CODE, contains("c.m"), contains("c.s"), FENCED) %>%
  select(-skim_type) %>% 
  ggplot(aes(yr, SPECIES_CODE)) +
  geom_tile(aes(fill = numeric.mean)) +
  geom_text(aes(label = round(numeric.mean,1)), color = "white") +
  scale_fill_viridis() +
  labs(x = "Year", y = "Species", fill = "mean", title = "Mean Height - Core Range", subtitle = "Fenced/unfenced") +
  facet_wrap(~FENCED)
```

#### Count of Observations by Species  

```{r}

csv.all.lc.mcro.df %>% 
  group_by(SPECIES_CODE) %>%
  tally() %>% 
  arrange(desc(n)) %>% 
  datatable(rownames = FALSE, caption = "Count of observations by shrub species.")

```

```{r, eval=FALSE}
csv.all.lc.mcro.df %>%
  write_csv("./output/exported_data/willow_mcro.csv")

```



## Aspen 

**Master excel file: Aspen_Data_Baseline_through_2018.xlsx**

The excel datafile provided by RMNP (Aspen_Data_Baseline_Through_2018.xlsx) includes **10 tabs**.

```{r}
## **Data import** 
asp <- readxl::excel_sheets("./data/EVMP_data/TenYearReview/Aspen_Data_Baseline_Through_2018.xlsx")

path <- ("data/EVMP_data/TenYearReview/Aspen_Data_Baseline_Through_2018.xlsx")

#### Read in the worksheets and create list of df
# each tab is a df in the list object
asp.d <- path %>% 
  excel_sheets() %>% 
  set_names() %>% 
  map(read_excel, path = path, na = "NA")  

# asp.d$`Aspen Baseline Stem Tallies` %>% 
#   View()

```



```{r}

### check out 'keep' and 'discard'

######
## site info tabs. read and clean
asp.siteinfo2018 <- asp.d$'Aspen 2018 Site Info'
asp.siteinfo2018 <- asp.siteinfo2018 %>% 
  filter(!is.na(DATE))
# write_csv(asp.siteinfo2018, "./data/EVMP_derived/asp_siteinfo2018.csv")

asp.siteinfo_baseline <- asp.d$'Aspen Baseline Site Info'
asp.siteinfo_baseline <- asp.siteinfo_baseline %>% 
  filter(!is.na(DATE))
# write_csv(asp.siteinfo_baseline, "./data/EVMP_derived/asp_siteinfoBaseline.csv")

######

## select the tabs with tally data
asp.d.sel <- asp.d[c(3,4,5,6,8,10)] 

## combine
asp.tally.all <- bind_rows(asp.d.sel, .id = "tab") 

## fix inconsistent labels
asp.tally.all <- 
  asp.tally.all %>% 
  mutate(SITE_ID = case_when(SITE_ID == "AC1" ~ "AC01",
                       SITE_ID == "AC2" ~ "AC02",
                       SITE_ID == "AC3" ~ "AC03", 
                       SITE_ID == "AC4" ~ "AC04", 
                       SITE_ID == "AC4" ~ "AC04",
                       SITE_ID == "AC5" ~ "AC05",
                       SITE_ID == "AC6" ~ "AC06", 
                       SITE_ID == "AC7" ~ "AC07", 
                       SITE_ID == "AC8" ~ "AC08",
                       SITE_ID == "AC9" ~ "AC09",
                       SITE_ID == "ANC1" ~ "ANC01",
                       SITE_ID == "ANC1" ~ "ANC01",
                       SITE_ID == "ANC2" ~ "ANC02",
                       SITE_ID == "ANC3" ~ "ANC03", 
                       SITE_ID == "ANC4" ~ "ANC04", 
                       SITE_ID == "ANC4" ~ "ANC04",
                       SITE_ID == "ANC5" ~ "ANC05",
                       SITE_ID == "ANC6" ~ "ANC06", 
                       SITE_ID == "ANC7" ~ "ANC07", 
                       SITE_ID == "ANC8" ~ "ANC08",
                       SITE_ID == "ANC9" ~ "ANC09",
                       SITE_ID == "AK1" ~ "AK01",
                       SITE_ID == "AK2" ~ "AK02",
                       SITE_ID == "AK3" ~ "AK03", 
                       SITE_ID == "AK4" ~ "AK04", 
                       SITE_ID == "AK4" ~ "AK04",
                       SITE_ID == "AK5" ~ "AK05",
                       SITE_ID == "AK6" ~ "AK06", 
                       SITE_ID == "AK7" ~ "AK07", 
                       SITE_ID == "AK8" ~ "AK08",
                       SITE_ID == "AK9" ~ "AK09",
                       TRUE ~ as.character(SITE_ID))
  )


## join in site info
asp.tally.all <- left_join(asp.tally.all, site.info.clean, by = "SITE_ID")

## make the 'NA' for the 'SITE_TYPE' field 'N' instead
asp.tally.all <- asp.tally.all %>% 
  mutate(FENCED = case_when(FENCED == "NA_" ~ "N",
                            is.na(FENCED) ~ "N",
                            TRUE ~ as.character(FENCED))
  ) 


## clean up BURNED: 'NA' to 'N'
asp.tally.all <- 
  asp.tally.all %>%
  mutate(BURNED = case_when(is.na(BURNED) ~ 'Not burned',
                            TRUE ~ as.character(BURNED)))

### write table
# write_csv(asp.tally.all, "./data/EVMP_derived/asp_tally_all.csv")

```


```{r, eval=FALSE}

asp.tally.all %>% 
  group_by(BURNED, FENCED) %>% 
  tally()%>% 
  gt::gt()

# aspen combined variable names
asp.tally.all %>% 
  names() %>% 
  enframe() %>% 
  gt::gt()

```


```{r, eval=FALSE}
# asp.d.sel.comb %>% 
#   janitor::tabyl(tab,SITE_TYPE) %>% 
#   flextable()
# _Tally of records by tab and core, non-core, and Kawuneeche Valley sites_

asp.tally.all %>% 
  janitor::tabyl(tab,SITE_TYPE) %>% 
  gt::gt()

```


_Tally of records by year and core, non-core, and Kawuneeche Valley sites_
```{r}
asp.tally.all %>% 
  janitor::tabyl(YEAR,SITE_TYPE) %>% 
  gt::gt()

```

_Tally of records by site type (e.g., core, non-core, and Kawuneeche Valley sites) and fenced status_
```{r}

asp.tally.all %>% 
  janitor::tabyl(SITE_TYPE, FENCED) %>% 
  gt::gt()

```

```{r}
asp.tally.all %>% 
  filter(SITE_TYPE == 'AK') %>% 
  select(SITE_ID, contains("DB")) %>% 
  gt()
```

_Tally of records by SITE_ID and YEAR_
```{r}

asp.gt1 <- asp.tally.all %>% 
  janitor::tabyl(SITE_ID, YEAR) %>% 
  gt::gt()

## tbl formatting
# asp.gt1 <- asp.gt1 %>% 
#   tab_style(
#     style = list(
#       cell_fill(color = "lightcyan"),
#       cell_text(weight = "bold")
#       ),
#     locations = cells_data(
#       columns = vars('2006', '2007'),
#       rows = SITE_ID == "2")
#   ) 
# asp.gt1

```


```{r}

## tidy the dbh
asp.tally.dbh.tidy <- asp.tally.all %>%
  pivot_longer(
    cols = starts_with("DBH"),
    names_to = "DBHclass",
    values_to = "DBHval"
  )

asp.tally.dbh.tidy <- asp.tally.dbh.tidy %>% 
  select(-contains("HT_"))


## tidy the height
asp.tally.ht.tidy <- asp.tally.all %>%
  pivot_longer(
    cols = starts_with("HT_"),
    names_to = "HTclass",
    values_to = "HTval"
  )

asp.tally.ht.tidy <- asp.tally.ht.tidy %>% 
  select(-contains("DBH"))

```


```{r asp_dbhmod}
## mod the dbh
asp.tally.dbh.tidy <- asp.tally.dbh.tidy %>% 
  mutate(DBHclassFact = as_factor(DBHclass))

asp.tally.dbh.tidy <- asp.tally.dbh.tidy %>% 
  mutate(timeClass = case_when(YEAR == 2006 ~ "BL",
                               YEAR == 2007 ~ "BL",
                               YEAR == 2008 ~ "BL",
                               YEAR == 2009 ~ "BL",
                               TRUE ~ as.character(YEAR))) %>%  
  mutate(timeClass = factor(timeClass, levels = c("BL", "2013","2015","2016","2017","2018")))  # set as factor, set levels


### reanme the HTval to something more directly interpretable
### then convert to stem density/ha
asp.tally.dbh.tidy <- 
  asp.tally.dbh.tidy %>% 
  rename(stemTally = DBHval) 

## Create a new field to combine the 2cm dbh bands into smaller number of classes. 
# write a table to use as look-up
# asp.tally.tidy %>% 
#   distinct(DBHclassFact) %>% 
#   write_csv('./data/EVMP_derived/DBHclassFact_lu.csv')

# read in the lu
dbh.lu <- read_csv('./data/EVMP_derived/DBHclassFact_lu.csv')

asp.tally.dbh.tidy <- left_join(asp.tally.dbh.tidy, dbh.lu, by = "DBHclassFact")

## collapse the tallies by DBHclGp01
asp.tally.dbh.tidy <- asp.tally.dbh.tidy %>%
  group_by(SITE_ID, timeClass, SITE_TYPE, REMOVED, BURNED, FENCED, VALLEY, RANGE_TYPE, LIVE_DEAD, DBHclGp01) %>% 
  summarise(stemTally = sum(stemTally)) %>%
  filter(!is.na(VALLEY)) %>% 
  ungroup() %>% 
  mutate(stemDen.ha = stemTally *400) %>% # converts stems/2m2 plot to stems/ha
  mutate(stemDen.ac = stemTally *161.8744) # converts stems/2m2 plot to stems/acre

```

```{r asp_htMod}
## mod the ht
asp.tally.ht.tidy <- asp.tally.ht.tidy %>% 
  mutate(timeClass = case_when(YEAR == 2006 ~ "BL",
                               YEAR == 2007 ~ "BL",
                               YEAR == 2008 ~ "BL",
                               YEAR == 2009 ~ "BL",
                               TRUE ~ as.character(YEAR))) %>% 
  mutate(timeClass = factor(timeClass, levels = c("BL", "2013","2015","2016","2017","2018")))  # set as factor, set levels

### reanme the HTval to something more directly interpretable
### then convert to stem density/ha
asp.tally.ht.tidy <- 
  asp.tally.ht.tidy %>% 
  rename(stemTally = HTval) %>% 
  mutate(stemDen.ha = stemTally *400) %>% # converts stems/2m2 plot to stems/ha
  mutate(stemDen.ac = stemTally *161.8744) # converts stems/2m2 plot to stems/acre

```


### Aspen DBH: Core winter range


```{r asp_dbh_tileTally}

asp.tally.dbh.tidy %>%
  filter(LIVE_DEAD == 'LIVE') %>% 
  filter(RANGE_TYPE == "core winter range") %>% 
  # filter(SITE_ID == "AC60") %>% select(-contains("UT")) %>% datatable()
  # ggplot(aes(timeClass, DBHclGp01)) +
  ggplot(aes(timeClass, DBHclGp01)) +  
  geom_tile(aes(fill = FENCED), color = "white", alpha = .2) +
  geom_text(aes(label = stemTally), size = 3) +
  facet_wrap(~SITE_ID) +
  theme_bw() +
  labs(x = "", y = "", title = "Aspen live stem tallies", subtitle = "Core winter range") +
  # facet_grid(SITE_ID ~ timeClass) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```

```{r, eval=FALSE}
## in progress
asp.tally.dbh.tidy %>%
  filter(LIVE_DEAD == 'LIVE') %>% 
  filter(RANGE_TYPE == "core winter range") %>% 
  # filter(SITE_ID == "AC60") %>% select(-contains("UT")) %>% datatable()
  # ggplot(aes(timeClass, DBHclGp01)) +
  ggplot(aes(timeClass, DBHclGp01)) +  
  geom_tile(aes(fill = FENCED), color = "white", alpha = .2) +
  geom_text(aes(label = stemTally), size = 3) +
  # facet_wrap(~SITE_ID) +
  facet_grid(FENCED~VALLEY) +
  theme_bw() +
  labs(x = "", y = "", title = "Moraine Park: Aspen live stem tallies") +
  # facet_grid(SITE_ID ~ timeClass) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))


```

#### Aspen : stem density per acre - core winter range

or do we want ha?

```{r, fig.height=8, fig.width=8}
asp.tally.dbh.tidy %>%
  filter(timeClass == "BL" | timeClass == "2013" | timeClass == "2018") %>% 
  filter(LIVE_DEAD == 'LIVE') %>% 
  filter(RANGE_TYPE == "core winter range") %>% 
  # filter(SITE_ID == "AC60") %>% select(-contains("UT")) %>% datatable()
  # ggplot(aes(timeClass, DBHclGp01)) +
  ggplot(aes(timeClass, DBHclGp01)) +  
  geom_tile(aes(fill = stemDen.ac), color = "white", alpha = .52) +
  scale_fill_viridis_c() +
  geom_text(aes(label = round(stemDen.ac,0)),size = 2.13) +
  facet_wrap(~SITE_ID, ncol = 6) +
  theme_bw() +
  labs(x = "", y = "", title = "Aspen live stem density", subtitle = "Core winter range", fill = "Stems/acre", y = "DBH class") +
  # facet_grid(SITE_ID ~ timeClass) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# ggsave("./output/figures_exported/AspCoreWR_stemsAc_tile_b.png", width = 10.5, height = 7)

```

#### Aspen : live stem density per acre - core winter range

or do we want ha?

```{r, fig.height=6, fig.width=6}
asp.tally.dbh.tidy %>%
  # distinct(RANGE_TYPE)
  filter(LIVE_DEAD == 'LIVE') %>% 
  filter(RANGE_TYPE == "non-core winter range") %>% 
  # filter(SITE_ID == "AC60") %>% select(-contains("UT")) %>% datatable()
  # ggplot(aes(timeClass, DBHclGp01)) +
  ggplot(aes(timeClass, DBHclGp01)) +  
  geom_tile(aes(fill = stemDen.ac), color = "white", alpha = .52) +
  scale_fill_viridis_c() +
  geom_text(aes(label = round(stemDen.ac,0)),size = 2.13) +
  facet_wrap(~SITE_ID, ncol = 6) +
  theme_bw() +
  labs(x = "", y = "", title = "Aspen live stem density", subtitle = "Non-core winter range", fill = "Stems/acre", y = "DBH class") +
  # facet_grid(SITE_ID ~ timeClass) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# ggsave("./output/figures_exported/AspNCoreWR_stemsAc_tile.png", width = 7.5, height = 4)

```

#### Aspen : live stem density per acre - Kawuneeche Valley



```{r, fig.height=3.75, fig.width=5}
asp.tally.dbh.tidy %>%
  # distinct(RANGE_TYPE)
  filter(LIVE_DEAD == 'LIVE') %>% 
  filter(RANGE_TYPE == "Kawuneeche Valley") %>% 
  # filter(SITE_ID == "AC60") %>% select(-contains("UT")) %>% datatable()
  # ggplot(aes(timeClass, DBHclGp01)) +
  ggplot(aes(timeClass, DBHclGp01)) +  
  geom_tile(aes(fill = stemDen.ac), color = "white", alpha = .52) +
  scale_fill_viridis_c() +
  geom_text(aes(label = round(stemDen.ac,0)),size = 2.13) +
  facet_wrap(~SITE_ID, ncol = 4) +
  theme_bw() +
  labs(x = "", y = "", title = "Aspen live stem density", subtitle = "Kawuneeche Valley", fill = "Stems/acre", y = "DBH class") +
  # facet_grid(SITE_ID ~ timeClass) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# ggsave("./output/figures_exported/AspKW_stemsAc_tile.png", width = 4.75, height = 3.15)

```

#### Aspen: live stem density summary table

```{r}
asp.den.summary <- asp.tally.dbh.tidy %>%
  filter(LIVE_DEAD == 'LIVE') %>% 
  group_by(timeClass, RANGE_TYPE, FENCED) %>% 
  summarise(mean.den.ac = round(mean(stemDen.ac, na.rm=TRUE), 1), sd.den.ac = round(sd(stemDen.ac,na.rm=TRUE),1), median.den.ac = round(median(stemDen.ac, na.rm=TRUE),1), iqr.den.ac = round(IQR(x = stemDen.ac, type = 8, na.rm = TRUE),1), max.den.ac = round(max(stemDen.ac),1),n = n())

#Type 8
# m = (p+1)/3. p[k] = (k - 1/3) / (n + 1/3). Then p[k] =~ median[F(x[k])]. The resulting quantile estimates are approximately median-unbiased regardless of the distribution of x.


asp.den.summary %>% 
  datatable(filter="bottom")

```

```{r}
asp.den.summary %>% 
  pivot_wider(names_from = FENCED,
              values_from = c(median.den.ac, mean.den.ac)) %>% 
  datatable()


```


```{r}
# asp.tally.dbh.tidy %>% 
#   filter(LIVE_DEAD == 'LIVE') %>% 
#   filter(RANGE_TYPE == "core winter range") %>% 
#   filter(SITE_ID == "AC60") %>%
#   # select(-contains("UT")) %>% datatable()
#   # ggplot(aes(timeClass, DBHclGp01)) +
#   ggplot(aes(timeClass, DBHclass)) +  
#   geom_tile(aes(fill = FENCED), color = "white", alpha = .2) +
#   geom_text(aes(label = stemTally), size = 3) +
#   facet_wrap(~SITE_ID) +
#   theme_bw() +
#   labs(x = "", y = "", title = "Moraine Park: Aspen dead stem tallies") +
#   # facet_grid(SITE_ID ~ timeClass) +
#   theme(axis.text.x = element_text(angle = 45, hjust = 1))

```


_DBH classes: Fenced and non-burned plots_
```{r}
## Add objectives

## DBH
dbh.perc <- asp.tally.dbh.tidy %>%
  # filter(is.na(REMOVED)) %>% 
  filter(BURNED == "Not burned") %>%
  filter(LIVE_DEAD == "LIVE") %>%
  filter(FENCED == "Y") %>%
  # filter(SITE_TYPE == "AC") %>%
  # filter(timeClass %in% c('BL','2013','2018')) %>%
  group_by(SITE_ID, timeClass) %>%
  mutate(sumStem = sum(stemTally)) %>% 
  ungroup() %>% 
  mutate(percentTot = stemTally/sumStem) 


## heatmap
# dbh.perc %>%
#   # datatable()
#   # distinct(timeClass)
#   filter(!is.nan(percentTot)) %>%
#   ggplot(aes(DBHclGp01, SITE_ID)) +
#   geom_tile(aes(fill = percentTot), color = 'white') +
#   facet_grid(.~timeClass) +
#   scale_fill_viridis_c(begin = .01, end = .9, direction = -1) +
#   theme_minimal() +
#   labs(x = "DBH class", y = "", fill = "% total stems", title = "Proportion of Live Aspen Stems by DBH Class", subtitle = "Fenced and unburned plots only")

# ggsave("./output/figures/AC_Live_Fenced_Unburned_PropDBH_heatmap.png", width = 7, height = 5, dpi = 300)

# dbh.perc %>%
#   # distinct(timeClass)
#   filter(!is.nan(percentTot)) %>%
#   ggplot(aes(SITE_ID, percentTot)) +
#   # geom_col(aes(fill = DBHclGp01), color = "darkgray") +
#   geom_col(aes(fill = DBHclGp01)) +
#   facet_wrap(~timeClass, ncol = 3) +
#   # scale_fill_viridis_d(option = "D") +
#   scale_fill_manual(values = c("bisque1", "bisque3", "bisque4")) +
#   # scale_fill_manual(values = c("honeydew2", "honeydew3", "honeydew4")) +
#   theme_minimal() +
#   labs(y = "Proportion of stems", x = "", fill = "DBH class", title = "Proportion of Live Aspen Stems by DBH Class", subtitle = "Fenced and unburned plots only") +
#   theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
#   theme(legend.position = "top")
  
# ggsave("./output/figures/AC_Live_Fenced_Unburned_PropDBH_barChart.png", width = 8, height = 6, dpi = 300)

dbh.perc %>%
  filter(SITE_ID != "AC67") %>% 
  filter(!is.nan(percentTot)) %>%
  filter(timeClass %in% c("BL","2013","2018")) %>% 
  ggplot(aes(timeClass, percentTot)) +
  # geom_col(aes(fill = DBHclGp01), color = "darkgray") +
  geom_col(aes(fill = DBHclGp01)) +
  facet_wrap(~SITE_ID, ncol = 5) +
  # scale_fill_manual(values = c("bisque1", "bisque3", "bisque4")) +
  scale_fill_manual(values = c("honeydew2", "honeydew3", "darkolivegreen")) +
  # theme_minimal() +
  theme_bw() +
  labs(y = "Proportion of stems", x = "", fill = "DBH class", title = "Proportion of Live Aspen Stems by DBH Class", subtitle = "Fenced and unburned plots only") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  theme(legend.position = "top") +
  scale_y_continuous(labels=scales::percent)

# ggsave("./output/figures/aspen_tally_plots/AC_Live_Fenced_Unburned_PropDBH_bc.png", width = 8, height = 6, dpi = 300)


```


_DBH classes: Fenced and burned plots_
```{r}
## DBH
dbh.perc2 <- asp.tally.dbh.tidy %>%
  filter(is.na(REMOVED)) %>% 
  filter(BURNED == "Burned") %>%
  filter(LIVE_DEAD == "LIVE") %>%
  filter(FENCED == "Y") %>%
  filter(SITE_TYPE == "AC") %>%
  # filter(timeClass %in% c('BL','2013','2018')) %>%
  group_by(SITE_ID, timeClass) %>%
  mutate(sumStem = sum(stemTally)) %>% 
  ungroup() %>% 
  mutate(percentTot = stemTally/sumStem) 

# dbh.perc2 %>%
#   filter(!is.nan(percentTot)) %>%
#   ggplot(aes(SITE_ID, percentTot)) +
#   # geom_col(aes(fill = DBHclGp01), color = "darkgray") +
#   geom_col(aes(fill = DBHclGp01)) +
#   facet_wrap(~timeClass, ncol = 3) +
#   # scale_fill_viridis_d(option = "D") +
#   # theme_minimal() +
#   theme_bw() +
#   labs(y = "Proportion of stems", x = "", fill = "DBH class", title = "Proportion of Live Aspen Stems by DBH Class", subtitle = "Fenced and burned plots only") +
#   theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
#   theme(legend.position = "top")
  
# ggsave("./output/figures/AC_Live_Fenced_Burned_PropDBH_barChart.png", width = 8, height = 6, dpi = 300)

dbh.perc2 %>%
  filter(!is.nan(percentTot)) %>%
  ggplot(aes(timeClass, percentTot)) +
  # geom_col(aes(fill = DBHclGp01), color = "darkgray") +
  geom_col(aes(fill = DBHclGp01)) +
  facet_wrap(~SITE_ID, ncol = 3) +
  # scale_fill_viridis_d(option = "D") +
  scale_fill_manual(values = c("honeydew2", "honeydew3", "darkolivegreen")) +
  # theme_minimal() +
  theme_bw() +
  labs(y = "Proportion of stems", x = "", fill = "DBH class", title = "Proportion of Live Aspen Stems by DBH Class", subtitle = "Fenced and burned plots only") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  theme(legend.position = "top") +
  scale_y_continuous(labels=scales::percent)

# ggsave("./output/figures/AC_Live_Fenced_Burned_PropDBH_bc.png", width = 8, height = 6, dpi = 300)

```


_DBH classes: Unfenced and unburned plots_
```{r}
## DBH
dbh.perc3 <- asp.tally.dbh.tidy %>%
  filter(is.na(REMOVED)) %>% 
  filter(BURNED == "Not burned") %>%
  filter(LIVE_DEAD == "LIVE") %>%
  filter(FENCED == "N") %>%
  filter(SITE_TYPE == "AC") %>%
  filter(timeClass %in% c('BL','2013','2018')) %>%
  group_by(SITE_ID, timeClass) %>%
  mutate(sumStem = sum(stemTally)) %>% 
  ungroup() %>% 
  mutate(percentTot = stemTally/sumStem) 

## heatmap
# dbh.perc3 %>%
#   filter(!is.nan(percentTot)) %>%
#   ggplot(aes(DBHclGp01, SITE_ID)) +
#   geom_tile(aes(fill = percentTot), color = 'white') +
#   facet_grid(.~timeClass) +
#   scale_fill_viridis_c(begin = .01, end = .9, direction = -1) +
#   theme_minimal() +
#   labs(x = "DBH class", y = "", fill = "% total stems", title = "Proportion of Live Aspen Stems by DBH Class", subtitle = "Unfenced and unburned plots only")

# ggsave("./output/figures/Asp_unFenced_unburned_Live_AC_PropDBH_heatmap02.png", width = 7, height = 5, dpi = 300)

# dbh.perc3 %>%
#   filter(!is.nan(percentTot)) %>%
#   ggplot(aes(SITE_ID, percentTot)) +
#   geom_col(aes(fill = DBHclGp01)) +
#   facet_wrap(~timeClass, ncol = 1) +
#   # scale_fill_viridis_d(option = "D") +
#   theme_minimal() +
#   labs(y = "% total stems", x = "", fill = "DBH class", title = "Proportion of Live Aspen Stems by DBH Class", subtitle = "Unfenced and unburned plots only") +
#   theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
#   theme(legend.position = "top") +
#   scale_y_continuous(labels=scales::percent) 

dbh.perc3 %>%
  filter(!is.nan(percentTot)) %>%
  filter(SITE_ID != "AC68" & SITE_ID != "AC09" & SITE_ID != "AC30" & SITE_ID != "AC07" & SITE_ID != "AC37" & SITE_ID != "AC39") %>% 
  ggplot(aes(timeClass, percentTot)) +
  geom_col(aes(fill = DBHclGp01)) +
  facet_wrap(~SITE_ID, ncol = 6) +
  # scale_fill_viridis_d(option = "D") +
  scale_fill_manual(values = c("honeydew2", "honeydew3", "darkolivegreen")) +
  theme_bw() +
  labs(y = "% total stems", x = "", fill = "DBH class", title = "Proportion of Live Aspen Stems by DBH Class", subtitle = "Unfenced and unburned plots only") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  theme(legend.position = "top") +
  scale_y_continuous(labels=scales::percent) 

# ggsave("./output/figures/aspen_tally_plots/AC_Live_unfenced_Unburned_PropDBH_bc.png", width = 8, height = 6, dpi = 300)

```

Means of aspen sapling (plants with height less than or equal to 2.5 meters) density at aspen monitoring sites at sites burned in the 2012 Fern Lake Fire compared to unburned sites in Rocky Mountain National Park, Colorado. Baseline data collected 2006–9, with most of the sites collected in 2007 or 2008.

```{r}

```


#### Aspen DBH: Non-core winter range

_DBH classes: Non-fenced and non-burned plots_
```{r}
## DBH
dbh.perc4 <- asp.tally.dbh.tidy %>%
  filter(is.na(REMOVED)) %>% 
  filter(BURNED == "Not burned") %>%
  filter(LIVE_DEAD == "LIVE") %>%
  filter(FENCED == "N") %>%
  filter(SITE_TYPE == "ANC") %>%
  # filter(timeClass %in% c('BL','2013','2018')) %>%
  group_by(SITE_ID, timeClass) %>%
  mutate(sumStem = sum(stemTally)) %>% 
  ungroup() %>% 
  mutate(percentTot = stemTally/sumStem) 

## bar plot
dbh.perc4 %>%
  filter(!is.nan(percentTot)) %>%
  ggplot(aes(timeClass, percentTot)) +
  # geom_col(aes(fill = DBHclGp01), color = "darkgray") +
  geom_col(aes(fill = DBHclGp01)) +
  facet_wrap(~SITE_ID, ncol = 6) +
  scale_fill_manual(values = c("honeydew2", "honeydew3", "darkolivegreen")) +
  theme_bw() +
  labs(y = "% total stems", x = "", fill = "DBH class", title = "Proportion of Live Aspen Stems by DBH Class", subtitle = "Non-core sites, unfenced and unburned plots only") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  theme(legend.position = "top") +
  scale_y_continuous(labels=scales::percent) 
  
# ggsave("./output/figures/ANC_Live_unFenced_Unburned_PropDBH_bc.png", width = 8, height = 6, dpi = 300)

```


#### Aspen DBH: Kawuneeche Valley

_DBH classes: Unfenced and unburned plots_
```{r asp_dbh_KV}
## DBH
dbh.perc5 <- asp.tally.dbh.tidy %>%
  filter(is.na(REMOVED)) %>% 
  # filter(BURNED == "Not burned") %>%
  filter(LIVE_DEAD == "LIVE") %>%
  filter(FENCED == "N") %>%
  filter(SITE_TYPE == "AK") %>%
  # filter(timeClass %in% c('BL','2013','2018')) %>%
  # filter(timeClass == "BL" | timeClass == 2013 | timeClass == 2018) %>%
  group_by(SITE_ID, timeClass) %>%
  mutate(sumStem = sum(stemTally)) %>% 
  ungroup() %>% 
  mutate(percentTot = stemTally/sumStem) 


## bar plot
dbh.perc5 %>%
  filter(!is.nan(percentTot)) %>%
  ggplot(aes(timeClass, percentTot)) +
  # geom_col(aes(fill = DBHclGp01), color = "darkgray") +
  geom_col(aes(fill = DBHclGp01)) +
  facet_wrap(~SITE_ID, ncol = 4) +
  # scale_fill_viridis_d(option = "D") +
  # theme_minimal() +
  theme_bw() +
  labs(y = "% total stems", x = "", fill = "DBH class", title = "Proportion of Live Aspen Stems by DBH Class", subtitle = "Non-core sites, unfenced and unburned plots only") +
  scale_fill_manual(values = c("honeydew2", "honeydew3", "darkolivegreen")) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  theme(legend.position = "top") +
  scale_y_continuous(labels=scales::percent) 

# ggsave("./output/figures/aspen_tally_plots/AK_Live_unFenced_Unburned_PropDBH_bc.png", width = 8, height = 6, dpi = 300)

```



#### proportion of plots with regen above threshold

```{r}

asp.tally.dbh.tidy %>%
  filter(is.na(REMOVED)) %>% 
  filter(BURNED == "Not burned") %>%
  filter(LIVE_DEAD == "LIVE") %>%
  filter(FENCED == "N") %>%
  filter(SITE_TYPE == "ANC") %>%
  # filter(timeClass %in% c('BL','2013','2018')) %>%
  group_by(SITE_ID, timeClass) %>%
  mutate(sumStem = sum(stemTally)) %>% 
  ungroup() %>% 
  mutate(percentTot = stemTally/sumStem) 
```



```{r}

```

### Aspen height

#### Aspen height: Core winter range

```{r}

### Add Short/Tall stem field 
asp.tally.ht.tidy <- asp.tally.ht.tidy %>% 
  mutate(shortTall = case_when(HTclass == 'HT_0_50_CM' ~ "short",
                               HTclass == 'HT_51_100_CM' ~ "short",
                               HTclass == 'HT_101_150_CM' ~ "short",
                               HTclass == 'HT_151_200_CM' ~ "tall",
                               HTclass == 'HT_201_250_CM' ~ "tall")
         )


asp.tally.ht.tidy %>% 
  distinct(HTclass, shortTall) %>%
  gt()

```

```{r}
## join in dbh with height classes

asp.dbh2join <- asp.tally.dbh.tidy %>%
  select(c(SITE_ID, timeClass, DBHclGp01)) 

asp.dbh2join %>%
  glimpse()

ht.dbh.class <- left_join(asp.tally.ht.tidy, asp.dbh2join) %>% 
  filter(LIVE_DEAD != "DEAD") %>% 
  select(c(SITE_TYPE, SITE_ID, timeClass, stemTally, stemDen.ac, BURNED, FENCED, RANGE_TYPE, VALLEY, DBHclGp01, HTclass, shortTall))

ht.dbh.class <- ht.dbh.class %>%
    mutate(RANGE_TYPE = case_when(grepl("AC", SITE_ID) & is.na(RANGE_TYPE) ~ "core winter range",
                            TRUE ~ RANGE_TYPE))

```


#### suckering 1.5 m to 2.5 m in ht

```{r}
### suckering classes: by range type
# the following combines the tally for stems between 1.5 and 2.5 m
suckering.vtype <- ht.dbh.class %>%
    filter(HTclass == "HT_151_200_CM" |HTclass == "HT_201_250_CM") %>%
  group_by(SITE_ID, RANGE_TYPE, FENCED, timeClass) %>% 
  summarise(stemTally.1p5to2m = sum(stemTally)) %>%
  mutate(stemDen.ac = stemTally.1p5to2m *161.8744) %>% # converts stems/2m2 plot to stems/acre) %>% 
  # mutate(suckering_class = case_when(stemDen.ac < 1700 ~ "Poor (<1,700 stems/acre)",
  #                                  stemDen.ac >=1700 & stemDen.ac <4500 ~ "Moderate (1,700-4,500 stems/acre)",
  #                                  stemDen.ac >=4500 ~ "High (>4500 stems/acre)")) %>% 
  mutate(suckering_class = case_when(stemDen.ac < 1700 ~ "Poor",
                                   stemDen.ac >=1700 & stemDen.ac <4500 ~ "Moderate",
                                   stemDen.ac >=4500 ~ "High")) %>% 
  ungroup()

## fenced and unfenced
suckering.vtype %>%
  filter(!is.na(RANGE_TYPE)) %>%
  filter(RANGE_TYPE != "Kawuneeche Valley") %>%
  filter(timeClass %in% c("BL","2013","2018")) %>% 
  ggplot(aes(timeClass, SITE_ID)) +
  geom_tile(aes(fill = suckering_class), color = "white") +
  scale_fill_manual(values = c("darkgreen","green","grey90")) +
  theme_minimal() +
  theme(legend.position = "top") +
  labs(x = "", y = "Site ID", fill = "", caption = "Suckering: Stem density 1.5 m to 2.5 m in ht") +
  facet_wrap(~RANGE_TYPE, scales = "free_y")

# ggsave("./output/figures_exported/suckering_1p5to2p5m_AC_AN.png", width = 6.5, height = 7)

suckering.vtype %>%
  filter(!is.na(RANGE_TYPE)) %>% 
  filter(timeClass %in% c("BL","2013","2018")) %>% 
  arrange(-stemDen.ac) %>% 
  datatable(rownames = FALSE, caption = "stemDen.ac aspen suckering 1.5 m to 2.5 m", filter = "top")

## broken out by fenced, just for AC
suckering.vtype %>%
  filter(!is.na(RANGE_TYPE)) %>%
  filter(RANGE_TYPE == "core winter range") %>%
  # filter(RANGE_TYPE != "Kawuneeche Valley") %>%
  filter(timeClass %in% c("BL","2013","2018")) %>% 
  ggplot(aes(timeClass, SITE_ID)) +
  geom_tile(aes(fill = suckering_class), color = "white") +
  scale_fill_manual(values = c("darkgreen","green","grey90")) +
  theme_minimal() +
  # theme(legend.position = "top") +
  labs(x = "", y = "Site ID", fill = "", caption = "Suckering: Stem density 1.5 m to 2.5 m in ht. AC plots only") +
  # facet_grid(FENCED~RANGE_TYPE)
  facet_wrap(~FENCED, scales = "free_y")

# ggsave("./output/figures_exported/suckering_1p5to2p5m_AC_fenced.png", width = 5.5, height = 5)

```

```{r}

# prop func
prop.fun <- function(x, cnt){
  x = x/cnt
  x
}

# suckering.vtype.tabyl %>% 
#   # glimpse()
#   # mutate(n = sum(`High (>4500 stems/acre)`,`Moderate (1,700-4,500 stems/acre)`,`Poor (<1,700 stems/acre)`)) %>% 
#   # mutate_if(.predicate = is.numeric, prop.fun())
#   gt()

# suckering.vtype %>% distinct(SITE_ID)

suckering.vtype <- suckering.vtype %>% 
  mutate(RANGE_TYPE = case_when(grepl("AC", SITE_ID) & is.na(RANGE_TYPE) ~ "core winter range",
                            TRUE ~ RANGE_TYPE)) 
#### calc the percent 
percent_suckering_class <- suckering.vtype %>% 
  filter(!is.na(RANGE_TYPE)) %>% 
  mutate(timeClass = as.character(timeClass)) %>%
  filter(timeClass == "BL" | timeClass == "2013" | timeClass == "2018") %>%
  group_by(timeClass, RANGE_TYPE, suckering_class) %>% 
  summarise(sum_class = n()) %>% 
  ungroup() %>% 
  # tally()
  group_by(timeClass, RANGE_TYPE) %>% 
  mutate(n_allTimes = sum(sum_class)) %>% 
  ungroup() %>% 
  mutate(percent_in_class = 100*(sum_class/n_allTimes)) %>% 
  mutate(percent_in_class = round(percent_in_class, 1)) %>% 
  arrange(timeClass, suckering_class)
  
percent_suckering_class %>% 
  gt()
  


```

# >>> see up

```{r}
# fig for report
percent_suckering_class %>% 
  mutate(timeClass = as_factor(timeClass)) %>%
  mutate(timeClass = relevel(timeClass, "BL")) %>% 
  ggplot(aes(timeClass, percent_in_class)) +
  geom_col(aes(fill = suckering_class),  color = "white") +
  theme_minimal() +
  scale_fill_manual(values = c("darkgreen","lightgreen","ivory3")) +
  labs(x = "", y = "Percent of plots", fill = "") # +
  facet_wrap()# teme(legend.position = "top")

# ggsave("./output/figures_exported/suckering_proportion_all_plots_ht_class.png", width = 7, height = 3.85)

```

```{r}
#### calc the percent 
percent_suckering_class.vtype <- suckering.vtype %>% 
  filter(!is.na(RANGE_TYPE)) %>% 
  mutate(timeClass = as.character(timeClass)) %>%
  filter(timeClass == "BL" | timeClass == "2013" | timeClass == "2018") %>%
  group_by(timeClass, suckering_class, RANGE_TYPE) %>% 
  summarise(sum_class = n()) %>% 
  ungroup() %>% 
  group_by(timeClass, RANGE_TYPE) %>% 
  mutate(n_allTimes = sum(sum_class)) %>% 
  ungroup() %>% 
  mutate(percent_in_class = 100*sum_class/n_allTimes) %>% 
  mutate(percent_in_class = round(percent_in_class, 1))
  

percent_suckering_class.vtype %>% 
  datatable()

```

```{r}
#### Fig for report
percent_suckering_class.vtype %>% 
  mutate(timeClass = as_factor(timeClass)) %>%
  mutate(timeClass = relevel(timeClass, "BL")) %>% 
  mutate(RANGE_TYPE = as_factor(RANGE_TYPE)) %>%
  mutate(RANGE_TYPE = relevel(RANGE_TYPE, "core winter range","non-core winter range")) %>%
  ggplot(aes(timeClass, percent_in_class)) +
  geom_col(aes(fill = suckering_class), color = "white") +
  # geom_text(aes(label = percent_in_class)) +
  theme_minimal() +
  scale_fill_manual(values = c("darkgreen","lightgreen","ivory3")) +
  labs(x = "", y = "Percent of sites", fill = "") +
  facet_wrap(~RANGE_TYPE)

# ggsave("./output/figures_exported/suckering_proportion_all_plots_ht_class_rangety.png", width = 8, height = 3.85)

```


#### Stats suckering
```{r, echo=FALSE, eval = FALSE}

# see https://easystats.github.io/bayestestR/index.html

suckering.vtype <- suckering.vtype %>% 
  filter(!is.na(RANGE_TYPE))
  
suckering.vtype %>% 
  glimpse()

describe_posterior(
  rnorm(1000),
  centrality = "median",
  test = c("p_direction", "p_significance")
)

# ex2

zinb <- read.csv("http://stats.idre.ucla.edu/stat/data/fish.csv")
set.seed(123)
model <- brm(
  bf(
    count ~ child + camper + (1 | persons), 
    zi ~ child + camper + (1 | persons)
  ),
  data = zinb,
  family = zero_inflated_poisson(),
  chains = 1,
  iter = 500
)



```


```{r}
ht.dbh.class %>%
  group_by(RANGE_TYPE, timeClass, BURNED, FENCED, DBHclGp01, HTclass) %>% 
  summarise(mean.stemDen.ac = mean_r1(stemDen.ac), sd.stemDen.ac = sd_r1(stemDen.ac), n = n()) %>% 
  datatable(filter = "bottom")

```

#### Suckering: live unburned 
```{r}
ht.dbh.class.ub <- ht.dbh.class %>%
  filter(BURNED == "Not burned")
  
# ht.dbh.class %>% 
#   group_by(RANGE_TYPE, timeClass, FENCED, suckering_class) %>% 
#   summarise(mean.stemDen.ac = mean_r1(stemDen.ac), sd.stemDen.ac = sd_r1(stemDen.ac), n = n()) %>% 
#   ungroup() %>% 
#   mutate(suckering_class = case_when(mean.stemDen.ac < 1700 ~ "Poor (<1,700 stems/acre)",
#                                    mean.stemDen.ac >=1700 & mean.stemDen.ac <4500 ~ "Moderate (1,700-4,500 stems/acre)",
#                                    mean.stemDen.ac >=4500 ~ "High (>4500 stems/acre)")) 


# ht.dbh.class %>% 
#   pivot_wider(names_from = "suckering_class",values_from = )

ht.dbh.class %>% 
  datatable(filter = "bottom")
```


```{r asp_ht_clean}

## list of plot lacking a value for "RANGE_TYPE"
## on inspection, these have been dropped
## e.g., AC41 was washed away in 2013 floods (see E. Ertl 2018 notes)
## AC01 -  near Grand Lake
## None of these have data for 2018
# asp.tally.ht.tidy %>% 
#   filter(is.na(RANGE_TYPE)) %>% 
#   distinct(SITE_ID)
#   View()
# # A tibble: 5 x 1
#   SITE_ID
#   <chr>  
# 1 AC01   
# 2 AC21   
# 3 AC41   
# 4 AC12   
# 5 AC14

## CLEAN
asp.tally.ht.tidy <- asp.tally.ht.tidy %>%
  filter(!is.na(valley_full))  %>% ## drop the 4 plots
  filter(is.na(REMOVED))

## Convert stem counts to density 
## 4046.86 m2 = 1 acre conversion
## plot is 25m2
## scaler is: 161.8744   
## i.e., 1 stem/m2 = 161.8744 stems/acre

### create a better 'HTclass' for plotting
asp.tally.ht.tidy <- 
  asp.tally.ht.tidy %>% 
  mutate(HTclass2 = case_when(HTclass == "HT_0_50_CM" ~ "0-50cm",
                              HTclass == "HT_51_100_CM" ~ "51-100cm",
                              HTclass == "HT_101_150_CM" ~ "101-150cm",
                              HTclass == "HT_151_200_CM" ~ "151-200cm",
                              HTclass == "HT_201_250_CM" ~ "201-250cm")
         )


# set as factor, set levels
asp.tally.ht.tidy <- 
  asp.tally.ht.tidy %>% 
  mutate(HTclass2 = factor(HTclass2, levels = c("0-50cm", "51-100cm","101-150cm","151-200cm","201-250cm")))

```


```{r}

asp.tally.ht.tidy %>%
  # group_by(VALLEY) %>% tally()
  filter(VALLEY == "MP") %>% 
  ggplot(aes(HTclass2, stemTally)) +
  geom_col(aes(fill = LIVE_DEAD)) +
  facet_grid(SITE_ID ~ timeClass, as.table = FALSE) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

asp.tally.ht.tidy %>%
  # group_by(VALLEY) %>% tally()
  filter(FENCED == "Y") %>% 
  # filter(SITE_ID == "AC65") %>% 
  filter(VALLEY == "MP") %>% 
  ggplot(aes(HTclass2, stemTally)) +
  geom_col(aes(fill = LIVE_DEAD)) +
  facet_grid(SITE_ID ~ timeClass, as.table = FALSE) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))


asp.tally.ht.tidy %>%
  group_by(VALLEY) %>% tally()

asp.tally.ht.tidy %>%
  filter(LIVE_DEAD == 'LIVE') %>% 
  filter(VALLEY == "MP") %>%
  # filter(VALLEY == "EV") %>% 
  ggplot(aes(HTclass2, timeClass)) +
  geom_tile(aes(fill = stemTally), color = "white") +
  scale_fill_viridis_c() +
  facet_wrap(~SITE_ID) +
  theme_bw() +
  # facet_grid(SITE_ID ~ timeClass) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```



```{r asp_tally_tileTxt, include=TRUE, fig.width=11, fig.height=8}
### Core winter range: Aspen Stem Tallies

## tally of core winter range - LIVE
asp.tally.ht.tidy %>% # distinct(RANGE_TYPE)
  filter(LIVE_DEAD == 'LIVE') %>% 
  filter(RANGE_TYPE == "core winter range") %>%
  # filter(VALLEY == "MP") %>%
  # filter(VALLEY == "EV") %>% 
  ggplot(aes(timeClass, HTclass2)) +
  geom_tile(aes(fill = FENCED), color = "white", alpha = .2) +
  geom_text(aes(label = stemTally), size = 3) +
  # geom_tile(aes(fill = stemTally), color = "white") +
  # scale_fill_viridis_c() +
  facet_wrap(~SITE_ID) +
  theme_bw() +
  labs(x = "", y = "", title = "Core winter range: Aspen live stem tallies") +
  # facet_grid(SITE_ID ~ timeClass) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# ggsave("./output/figures/aspen_tally_plots/asp_core_liveTally.png", width = 9.5, height = 8, dpi = 300)
# ggsave("./output/figures/aspen_tally_plots/asp_core_liveTally.pdf", width = 11, height = 8.5, dpi = 300)


## tally of core winter range - DEAD
asp.tally.ht.tidy %>%
  filter(LIVE_DEAD == 'DEAD') %>% 
  filter(RANGE_TYPE == "core winter range") %>%
  ggplot(aes(timeClass, HTclass2)) +
  geom_tile(aes(fill = FENCED), color = "white", alpha = .2) +
  geom_text(aes(label = stemTally), size = 3) +
  facet_wrap(~SITE_ID) +
  theme_bw() +
  labs(x = "", y = "", title = "Moraine Park: Aspen dead stem tallies") +
  # facet_grid(SITE_ID ~ timeClass) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# ggsave("./output/figures/aspen_tally_plots/asp_core_deadTally.png", width = 9.5, height = 8, dpi = 300)
# ggsave("./output/figures/aspen_tally_plots/asp_core_deadTally.pdf", width = 11, height = 8.5, dpi = 300)


## tally of NON-core winter range - LIVE
asp.tally.ht.tidy %>% # distinct(RANGE_TYPE)
  filter(LIVE_DEAD == 'LIVE') %>%
  # distinct(RANGE_TYPE)
  filter(RANGE_TYPE == "non-core winter range") %>%
  filter(SITE_ID != "ANC24") %>% 
  ggplot(aes(timeClass, HTclass2)) +
  # geom_tile(aes(fill = FENCED), color = "white", alpha = .2) +
  geom_tile(aes(fill = stemTally), color = "white") +
  geom_text(aes(label = stemTally), size = 3) +
  # scale_fill_viridis_c() +
  scale_fill_viridis_c(begin = .4, end = .95, direction = -1, option = "B") +
  facet_wrap(~SITE_ID) +
  theme_bw() +
  labs(x = "", y = "", title = "Non-core winter range: Aspen live stem tallies") +
  # facet_grid(SITE_ID ~ timeClass) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
ggsave("./output/figures/aspen_tally_plots/asp_noncore_deadTally.png", width = 7.125, height = 5.5, dpi = 300)
# ggsave("./output/figures/aspen_tally_plots/asp_noncore_deadTally.pdf", width = 11, height = 8.5, dpi = 300)

## tally of NON-core winter range - LIVE
asp.tally.ht.tidy %>% # distinct(RANGE_TYPE)
  filter(LIVE_DEAD == 'LIVE') %>%
  # distinct(RANGE_TYPE)
  filter(RANGE_TYPE == "non-core winter range") %>%
  filter(SITE_ID != "ANC24") %>% 
  ggplot(aes(timeClass, HTclass2)) +
  # geom_tile(aes(fill = FENCED), color = "white", alpha = .2) +
  geom_tile(aes(fill = stemTally), color = "white") +
  geom_text(aes(label = stemTally), size = 3) +
  # scale_fill_viridis_c() +
  scale_fill_viridis_c(begin = .4, end = .95, direction = -1, option = "B") +
  facet_wrap(~SITE_ID) +
  theme_bw() +
  labs(x = "", y = "", title = "Non-core winter range: Aspen live stem tallies") +
  # facet_grid(SITE_ID ~ timeClass) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
# ggsave("./output/figures/aspen_tally_plots/asp_noncore_liveTally.png", width = 7.125, height = 5.5, dpi = 300)
# ggsave("./output/figures/aspen_tally_plots/asp_noncore_liveTally.pdf", width = 11, height = 8.5, dpi = 300)

## tally of NON-core winter range - LIVE
asp.tally.ht.tidy %>% # distinct(RANGE_TYPE)
  filter(LIVE_DEAD == 'LIVE') %>%
  # distinct(RANGE_TYPE)
  filter(RANGE_TYPE == "Kawuneeche Valley") %>%
  # filter(SITE_ID != "ANC24") %>% 
  ggplot(aes(timeClass, HTclass2)) +
  # geom_tile(aes(fill = FENCED), color = "white", alpha = .2) +
  geom_tile(aes(fill = stemTally), color = "white") +
  geom_text(aes(label = stemTally), size = 3) +
  # scale_fill_viridis_c() +
  scale_fill_viridis_c(begin = .4, end = .95, direction = -1, option = "B") +
  facet_wrap(~SITE_ID, ncol = 4) +
  theme_bw() +
  labs(x = "", y = "", title = "Kawuneeche Valley: Aspen live stem tallies") +
  # facet_grid(SITE_ID ~ timeClass) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
# ggsave("./output/figures/aspen_tally_plots/asp_KV_liveTally.png", width = 7.125, height = 5.5, dpi = 300)


```


```{r}

## tally of MP - LIVE
asp.tally.ht.tidy %>%
  filter(LIVE_DEAD == 'LIVE') %>% 
  filter(VALLEY == "MP") %>%
  # filter(VALLEY == "EV") %>% 
  ggplot(aes(timeClass, HTclass2)) +
  geom_tile(aes(fill = FENCED), color = "white", alpha = .2) +
  geom_text(aes(label = stemTally), size = 3) +
  # geom_tile(aes(fill = stemTally), color = "white") +
  # scale_fill_viridis_c() +
  facet_wrap(~SITE_ID) +
  theme_bw() +
  labs(x = "", y = "", title = "Moraine Park: Aspen live stem tallies") +
  # facet_grid(SITE_ID ~ timeClass) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# ggsave("./output/figures/aspen_tally_plots/asp_MP_liveTally.png", width = 9.5, height = 7, dpi = 300)


## tally of MP - DEAD
asp.tally.ht.tidy %>%
  filter(LIVE_DEAD == 'DEAD') %>% 
  filter(VALLEY == "MP") %>%
  ggplot(aes(timeClass, HTclass2)) +
  geom_tile(aes(fill = FENCED), color = "white", alpha = .2) +
  geom_text(aes(label = stemTally), size = 3) +
  facet_wrap(~SITE_ID) +
  theme_bw() +
  labs(x = "", y = "", title = "Moraine Park: Aspen dead stem tallies") +
  # facet_grid(SITE_ID ~ timeClass) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# ggsave("./output/figures/aspen_tally_plots/asp_MP_deadTally.png", width = 9.5, height = 7, dpi = 300)

```



```{r aspHtClass}
## calc percentage in height classes
ht.perc01 <- asp.tally.ht.tidy %>%
  filter(is.na(REMOVED)) %>% 
  filter(BURNED == "Not burned") %>%
  filter(LIVE_DEAD == "LIVE") %>%
  # filter(FENCED == "Y") %>%
  filter(SITE_TYPE == "AC") %>%
  filter(timeClass %in% c('BL','2013','2018')) %>%
  # filter(timeClass == "BL" | timeClass == 2013 | timeClass == 2018) %>%
  group_by(SITE_ID, timeClass) %>%
  mutate(sumStem = sum(stemTally)) %>% 
  ungroup() %>% 
  mutate(percentTot = stemTally/sumStem) #%>% 
  # mutate(percentTot = 100*round(percentTot,1)) 


```


```{r aspHtClass_plots}

## heatmap: fenced
ht.perc01 %>%
  mutate(percentTot = 100*round(percentTot,1)) %>% 
  filter(FENCED == "Y") %>%
  filter(SITE_ID != "AC33") %>% 
  filter(SITE_ID != "AC67") %>% 
  filter(!is.nan(percentTot)) %>%
  ggplot(aes(HTclass2, SITE_ID)) +
  geom_tile(aes(fill = percentTot), color = 'white', alpha = .8) +
  geom_text(aes(label = percentTot), size = 3) +
  facet_grid(.~timeClass) +
  scale_fill_viridis_c(begin = .4, end = .95, direction = -1, option = "B") +
  theme_bw() +
  # theme_minimal() +
  labs(x = "Height class", y = "", fill = "% total stems", title = "Proportion of Live Aspen Stems by Height Class", subtitle = "Fenced and unburned plots only")+
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# ggsave("./output/figures/aspen_tally_plots/AC_Live_Fenced_Unburned_heightClass_heatmap3.png", width = 8.5, height = 6, dpi = 300)
# ggsave("./output/figures/aspen_tally_plots/AC_Live_Fenced_Unburned_heightClass_heatmap2_w6h4p4.png", width = 6, height = 4.4, dpi = 300)


## heatmap: unfenced
ht.perc01 %>%
  mutate(percentTot = 100*round(percentTot,1)) %>% 
  filter(FENCED == "N") %>%
  filter(SITE_ID != "AC07") %>% 
  filter(SITE_ID != "AC68") %>% 
  filter(!is.nan(percentTot)) %>%
  ggplot(aes(HTclass2, SITE_ID)) +
  geom_tile(aes(fill = percentTot), color = 'white', alpha = .8) +
  geom_text(aes(label = percentTot), size = 3) +
  facet_grid(.~timeClass) +
  scale_fill_viridis_c(begin = .4, end = .95, direction = -1, option = "B") +
  theme_bw() +
  labs(x = "Height class", y = "", fill = "% total stems", title = "Proportion of Live Aspen Stems by Height Class", subtitle = "Unfenced and unburned plots only")+
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# ggsave("./output/figures/aspen_tally_plots/AC_Live_unFenced_Unburned_heightClass_heatmap3.png", width = 8.5, height = 6, dpi = 300)
# ggsave("./output/figures/aspen_tally_plots/AC_Live_unFenced_Unburned_heightClass_heatmap2_w6h4p4.png", width = 6, height = 4.4, dpi = 300)


## heatmap: KV
asp.tally.ht.tidy %>%
  filter(is.na(REMOVED)) %>% 
  filter(BURNED == "Not burned") %>%
  filter(LIVE_DEAD == "LIVE") %>%
  # filter(FENCED == "Y") %>%
  # filter(SITE_TYPE == "AC") %>%
  filter(timeClass %in% c('BL','2013','2018')) %>%
  # filter(timeClass == "BL" | timeClass == 2013 | timeClass == 2018) %>%
  group_by(SITE_ID, timeClass) %>%
  mutate(sumStem = sum(stemTally)) %>% 
  ungroup() %>% 
  mutate(percentTot = stemTally/sumStem) %>%
  mutate(percentTot = 100*round(percentTot,1)) %>% 
  filter(RANGE_TYPE == "Kawuneeche Valley") %>%
  # filter(FENCED == "N") %>%
  filter(SITE_ID != "AK04") %>% 
  filter(SITE_ID != "AC68") %>% 
  filter(!is.nan(percentTot)) %>%
  ggplot(aes(HTclass2, SITE_ID)) +
  geom_tile(aes(fill = percentTot), color = 'white', alpha = .8) +
  geom_text(aes(label = percentTot), size = 3) +
  facet_grid(.~timeClass) +
  scale_fill_viridis_c(begin = .4, end = .95, direction = -1, option = "B") +
  theme_bw() +
  labs(x = "Height class", y = "", fill = "% total stems", title = "Proportion of Live Aspen Stems by Height Class", subtitle = "Unfenced and unburned plots only")+
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

ggsave("./output/figures/aspen_tally_plots/KV_Live_unFenced_Unburned_heightClass_heatmap3.png", width = 8.5, height = 6, dpi = 300)
# ggsave("./output/figures/aspen_tally_plots/AC_Live_unFenced_Unburned_heightClass_heatmap2_w6h4p4.png", width = 6, height = 4.4, dpi = 300)



```


```{r, fig.height=7.5, fig.height=6.5}

## bar chart: fenced
ht.perc01 %>%
  filter(SITE_ID != "AC33") %>% 
  filter(SITE_ID != "AC67") %>%
  filter(FENCED == "Y") %>% 
  filter(!is.nan(percentTot)) %>%
  ggplot(aes(SITE_ID, percentTot)) +
  geom_col(aes(fill = HTclass2)) +
  facet_wrap(~timeClass, ncol = 3) +
  # facet_grid(FENCED~timeClass) +
  scale_fill_viridis_d(begin = .2, end = .95, direction = -1, option = "D") +
  # scale_fill_viridis_d(option = "D") +
  theme_bw() +
  labs(y = "% of total stems", x = "", fill = "Height class", title = "Proportion of Live Aspen Stems by Height Class", subtitle = "Fenced and unburned plots only") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  theme(legend.position = "top") +
  scale_y_continuous(labels=scales::percent)
  
# ggsave("./output/figures/aspen_tally_plots/AC_Live_Fenced_Unburned_heightClass_bc.png", width = 9.5, height = 7.5, dpi = 300)
# ggsave("./output/figures/aspen_tally_plots/AC_Live_Fenced_Unburned_heightClass_bc_w6h4p4.png", width = 6, height = 4.4, dpi = 300)

# non-fenced
ht.perc01 %>%
  filter(SITE_ID != "AC33") %>% 
  filter(SITE_ID != "AC67") %>%
  filter(FENCED == "N") %>% 
  filter(!is.nan(percentTot)) %>%
  ggplot(aes(SITE_ID, percentTot)) +
  geom_col(aes(fill = HTclass2)) +
  facet_wrap(~timeClass, ncol = 3) +
  # facet_grid(FENCED~timeClass) +
  scale_fill_viridis_d(begin = .2, end = .95, direction = -1, option = "D") +
  # scale_fill_viridis_d(option = "D") +
  theme_bw() +
  labs(y = "% of total stems", x = "", fill = "Height class", title = "Proportion of Live Aspen Stems by Height Class", subtitle = "Unfenced and unburned plots only") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  theme(legend.position = "top") +
  scale_y_continuous(labels=scales::percent)

# ggsave("./output/figures/aspen_tally_plots/AC_Live_unFenced_Unburned_heightClass_bc.png", width = 9.5, height = 7.5, dpi = 300)
# ggsave("./output/figures/aspen_tally_plots/AC_Live_unFenced_Unburned_heightClass_bc_w6h4p4.png", width = 6, height = 4.4, dpi = 300)


```



#### Aspen height: Non-core winter range

```{r}

```



#### Aspen height: Kawuneeche Valley

```{r}

```




### Aspen management goals

_Targets from Ziegenfuss and Johnson 2015:_

1.Progressive increase in aspen regeneration above the baseline level of 13 percent to at least 45 percent of winter range stands (presence of stems less than 2 cm dbh reaching 1.5–2.5 m tall).

#
```{r}

ht.perc01 %>%
  group_by(RANGE_TYPE, FENCED, pType) %>% 
  summarise(mean.stemDen.ac = mean_r1(stemDen.ac),n = n())
  # filter(SITE_ID != "AC33") %>% 
  # filter(SITE_ID != "AC67") %>%
  # filter(FENCED == "N") %>%
  # filter(!is.nan(percentTot))

asp.tally.dbh.tidy %>%
  # filter(is.na(REMOVED)) %>% 
  filter(BURNED == "Not burned") %>%
  filter(LIVE_DEAD == "LIVE") %>%
  filter(FENCED == "Y") %>%
  # filter(SITE_TYPE == "AC") %>%
  # filter(timeClass %in% c('BL','2013','2018')) %>%
  group_by(SITE_ID, timeClass) %>%
  mutate(sumStem = sum(stemTally)) %>% 
  ungroup() %>% 
  mutate(percentTot = stemTally/sumStem) 

```


```{r, echo=FALSE}
### Aspen repeated measures
# not run. See "EVMP aspen statistical analyses.Rmd"
## Repeated measures: Assumptions
# The repeated measures ANOVA makes the following assumptions about the data:
# 
# No significant outliers in any cell of the design. This can be checked by visualizing the data using box plot methods and by using the function identify_outliers() [rstatix package].
# Normality: the outcome (or dependent) variable should be approximately normally distributed in each cell of the design. This can be checked using the Shapiro-Wilk normality test (shapiro_test() [rstatix]) or by visual inspection using QQ plot (ggqqplot() [ggpubr package]).
# Assumption of sphericity: the variance of the differences between groups should be equal. This can be checked using the Mauchly’s test of sphericity, which is automatically reported when using the R function anova_test() [rstatix package]. Read more in Chapter @ref(mauchly-s-test-of-sphericity-in-r).

# Note that, if the above assumptions are not met there are a non-parametric alternative (Friedman test) to the one-way repeated measures ANOVA.
# 
# Unfortunately, there are no non-parametric alternatives to the two-way and the three-way repeated measures ANOVA. Thus, in the situation where the assumptions are not met, you could consider running the two-way/three-way repeated measures ANOVA on the transformed and non-transformed data to see if there are any meaningful differences.
# 
# If both tests lead you to the same conclusions, you might not choose to transform the outcome variable and carry on with the two-way/three-way repeated measures ANOVA on the original data.
# 
# It’s also possible to perform robust ANOVA test using the WRS2 R package.

# Compute and interpret the different repeated measures ANOVA in R.

# Check repeated measures ANOVA test assumptions

# Perform post-hoc tests, multiple pairwise comparisons between groups to identify which groups are different

```

```{r}
###### WRITE to disk for statistical analysis
# ht.perc01 %>% write_csv("./output/exported_data/asp_ht_perc1_20200309.csv")

# i think the one to use...
# asp.tally.dbh.tidy %>% 
#   write_csv("./output/exported_data/asp_ht_perc1_20200309.csv")
  
```


```{r, echo=FALSE, eval = FALSE}

## stat tests: differences
# R function to compute Wilcoxon test
# To perform two-samples Wilcoxon test comparing the means of two independent samples (x & y), the R function wilcox.test() can be used as follow:
# 
# wilcox.test(x, y, alternative = "two.sided")
# 
# x,y: numeric vectors
# alternative: the alternative hypothesis. Allowed value is one of “two.sided” (default), “greater” or “less”.

```


----

#### Repeated measures: aspen stem tally

Increase in aspen regeneration above the baseline level of 13 percent to at least 45 percent of winter range stands **(presence of stems less than 2 cm dbh reaching 1.5–2.5 m tall). **

Progressive shift in the distribution of stem sizes toward the desired future condition of 75 percent small-diameter stems, 20 percent medium-diameter stems, and 5 percent large-diameter stems.

```{r}
# Progressive increase in aspen regeneration above the baseline level of 13 percent to at least 45 percent of winter range stands (presence of stems less than 2 cm dbh reaching 1.5–2.5 m tall). Progressive shift in the distribution of stem sizes toward the desired future condition of 75 percent small-diameter stems, 20 percent medium-diameter stems, and 5 percent large-diameter stems.
```


### distribution of stem sizes toward the desired future condition of 75 percent small-diameter stems, 20 percent medium-diameter stems, and 5 percent large-diameter stems

```{r}

## identify the "in desired future condition" plots
ht.perc01 <- ht.perc01 %>%
  mutate(inDesFC = case_when(
    stemDen.ha >= 400 & HTclass2 == "151-200cm" ~ "in_dfc",
    stemDen.ha >= 400 & HTclass2 == "201-250cm" ~ "in_dfc",
    TRUE ~ "out_dfc"))

# ht.perc01 %>% 
#   View()

ht.perc01 %>%  distinct(RANGE_TYPE)

## in DFC summary
asp_inDFC_summary <- ht.perc01 %>% 
  group_by(RANGE_TYPE, FENCED, timeClass, inDesFC) %>%
  summarise(n_dfc = n()) %>% 
  ungroup() %>% 
  group_by(RANGE_TYPE, FENCED, timeClass) %>%
  mutate(n_tot = sum(n_dfc)) %>%
  ungroup() %>% 
  mutate(perc_inDFC = n_dfc/n_tot * 100) %>% 
  mutate(perc_inDFC = round(perc_inDFC, 1))

asp_inDFC_summary %>% 
  gt()

```

```{r}
asp_inDFC_summary %>%
  filter(inDesFC == "in_dfc") %>% 
  gt()
  ggplot()
```


## Willow Offtake


_Master excel file: Willow_Offtake_Data_2009_Through_2018.xlsx_

```{r, echo = FALSE}
# Looking for baseline data?  	
# 	Baseline data was collected over 2 seasons: 2008 and 2009.  
# 	The baseline data is located in an Excel spreadsheet at:
# 	EVMP > Vegetation > Analysis > 5 Year Review > Baseline Data from Linda
# 	
# Where is the Kawuneeche Baseline data?	
# 	The Kawuneeche Baseline data is in a worksheet in the Baseline.xls workbook as described above.    
# 	The Kawuneeche willow plots (KW 1 thru 8) were established in August/Sept 2011, just prior to the installation of the exclosure near Timber Creek CG.
# 	
# KEY	
# SITE_TYPE (WC=Willow core, WNC= Willow noncore, WK= Willow Kawuneeche Valley)	
# COLOR_OF_STEM_MARKER (BR=brown, G=green, BL=black, Y=yellow, GR=gray, BR-N=brown notched, W=white)	
# NUMBER_BROWSED_CAG_SHOOTS (# Browsed Current Annual Growth Shoots)	
# NUMBER_UNBROWSED_CAG_SHOOTS (# Unbrowsed Current Annual Growth Shoots)	
# BROWSED_OR_UNBROWSED (Measured shoot browsed (B) or unbrowsed (U)?)	
# ADDITIONAL_SHOOT (Additional shoot 1=yes, 0=no)	

```

```{r, echo=FALSE}
# The Kawuneeche willow plots (KW 1 thru 8) were established in August/Sept 2011, just prior to the installation of the exclosure near Timber Creek CG.
# 
# _KEY:_	
# 	
# SITE_TYPE (WC=Willow core, WNC= Willow noncore, WK= Willow Kawuneeche Valley)	
# 	
# COLOR_OF_STEM_MARKER (BR=brown, G=green, BL=black, Y=yellow, GR=gray, BR-N=brown notched, W=white)	
# 	
# NUMBER_BROWSED_CAG_SHOOTS (# Browsed Current Annual Growth Shoots)	
# 	
# NUMBER_UNBROWSED_CAG_SHOOTS (# Unbrowsed Current Annual Growth Shoots)	
# 	
# BROWSED_OR_UNBROWSED (Measured shoot browsed (B) or unbrowsed (U)?)	
# 	
# ADDITIONAL_SHOOT (Additional shoot 1=yes, 0=no)	
```

```{r, eval=FALSE}

# 	
# Looking for baseline data?  	
# 	Baseline data was collected over 2 seasons: 2008 and 2009.  
# 	The baseline data is located in an Excel spreadsheet at:
# 	EVMP > Vegetation > Analysis > 5 Year Review > Baseline Data from Linda
# 	
# Where is the Kawuneeche Baseline data?	
# 	The Kawuneeche Baseline data is in a worksheet in the Baseline.xls workbook as described above.    
# 	The Kawuneeche willow plots (KW 1 thru 8) were established in August/Sept 2011, just prior to the installation of the exclosure near Timber Creek CG.
# 	
# KEY	
# 	
# SITE_TYPE (WC=Willow core, WNC= Willow noncore, WK= Willow Kawuneeche Valley)	
# 	

```


```{r, eval=TRUE, echo = FALSE}

# data/EVMP_20181010/TenYearReview/Willow_Cumulative_Data_Baseline_Through_2018.xlsx
offt <- readxl::excel_sheets("./data/EVMP_data/TenYearReview/Willow_Offtake_Data_2009_Through_2018.xlsx") %>% 
  set_names()

offt %>% 
  enframe() %>% select(-value) %>% 
  gt() %>% 
  tab_header(title = "Tabs in workbook")

offt.sheets <- excel_sheets(path = "data/EVMP_data/TenYearReview/Willow_Offtake_Data_2009_Through_2018.xlsx")

## read in all of the tabs as 'data' in list column
offt.raw <- offt.sheets %>%
  enframe() %>% 
  rename(sheet = value) %>% 
  mutate(path = ("./data/EVMP_data/TenYearReview/Willow_Offtake_Data_2009_Through_2018.xlsx")) %>% 
  mutate(data = map2(.x = path,.y = sheet,.f = read_excel,col_types = "text")) %>% 
  select(-c(name))

```

```{r}
## remove the meta tab and create new field for season
offt.raw <- offt.raw %>% 
  filter(str_detect(sheet,pattern = "DIRE",negate = TRUE)) %>% 
  mutate(season = case_when(str_detect(sheet,pattern = "Spring") ~ "spring",
                            TRUE ~ "fall"))

offt.raw <- offt.raw %>% 
  mutate(yr = as.integer(str_sub(sheet,1,4))) %>% 
  filter(!is.na(yr))

# offt.raw %>% 
#   filter(is.na(yr)) # these are all fall sheets

# spring data
offt.raw.spr <- offt.raw %>%
  filter(season == "spring")

### there are these  "willow twig" sheets. 
willow.twigs.sheets <- offt.raw %>% 
  filter(is.na(yr))

# offt.raw.spr %>% glimpse()
# offt.raw.spr %>% visdat::vis_dat()

# unnest
offt.raw.spr.tidy <- offt.raw.spr %>%
  unnest(cols = data) %>% 
  janitor::clean_names()

offt.raw.spr.tidy %>% visdat::vis_dat()

## these sheets are missing diameters
offt.raw.spr.tidy %>% 
  filter(is.na(dia_base_of_shoot_mm)) %>% 
  distinct(sheet)
## these sheets are missing counts
offt.raw.spr.tidy %>% 
  filter(is.na(number_browsed_cag_shoots) & !is.na(total_stem_count)) %>% 
  datatable()

## type convert
offt.raw.spr.tidy <- offt.raw.spr.tidy %>% 
  # glimpse()
  mutate_at(.vars = c('number_browsed_cag_shoots','number_unbrowsed_cag_shoots', 'dia_base_of_shoot_mm','dia_tip_of_shoot_mm','shoot_length_cm','total_stem_count', 'shoot_ratio','calculated_count_of_shoots','plant_id_number','additional_shoot'),.funs = as.numeric) 

# data <- files %>%
#   map(read_csv) %>%    # read in all the files individually, using
#   reduce(rbind)        # reduce with rbind into one dataframe
# data  
  
```

```{r}
## some cleaning
######### DEAL WITH NA #############
# na_strings <- c(".", "na", "NA", "N A", "N / A", "N/A", "N/ A", "Not Available", "NOt available")
# 
# offt.raw.spr.tidy <- offt.raw.spr.tidy %>%
#   naniar::replace_with_na_all(condition = ~.x %in% na_strings)

```


```{r}
#### clean up mis entered site_id

offt.raw.spr.tidy <- offt.raw.spr.tidy %>% 
  mutate(site_id = case_when(
    site_id == "WC 39" ~ "WC39",
    site_id == "WC 50" ~ "WC50",
    TRUE ~ site_id)) 

```

```{r}
offt.raw.spr.tidy %>%
  # sample_n(10000) %>% 
  visdat::vis_dat() +
  theme_minimal() +
  coord_flip() +
  labs(caption = "offtake - spring")

```

# >>>>
```{r}
## 1. create unique stem id
offt.raw.spr.tidy <- offt.raw.spr.tidy %>% 
  mutate(stid = paste0(site_id,"-",microplot_location,"-",plant_id_number,"-", stem_id_letter))

## diagnose and fix issues with b/u
# these are not 
offt.raw.spr.tidy %>% 
  tabyl(browsed_or_unbrowsed) %>% 
  # distinct(browsed_or_unbrowsed) %>% 
  gt() %>% 
  tab_header("Distinct 'browsed_unbrowsed",subtitle = "need to stanrdized encoding and deal with NA")

# offt.raw.spr.tidy %>% 
#   tabyl(stid)

offt.raw.spr.tidy <- offt.raw.spr.tidy %>%
  mutate(browsed_or_unbrowsed = case_when(
    str_detect(browsed_or_unbrowsed,pattern = "u") ~ "U", 
    str_detect(browsed_or_unbrowsed,pattern = "b") ~ "B",              
                            TRUE ~ browsed_or_unbrowsed))

# !!!
### clean: 0 browsed doesn't make sense, right?
### here the records
offt.raw.spr.tidy %>%
  filter(browsed_or_unbrowsed == 0) %>% 
  datatable()

offt.raw.spr.tidy <- offt.raw.spr.tidy %>%
  filter(browsed_or_unbrowsed != 0) 

## table of NA. 
offt.raw.spr.tidy %>% 
  filter(browsed_or_unbrowsed == "NA") %>% 
  datatable(caption = "NA for B/U")

## eliminate NA. Should look at these, though
offt.raw.spr.tidy <- offt.raw.spr.tidy %>% 
  filter(browsed_or_unbrowsed != "NA")

```


```{r}
### Missing plant id
offt.raw.spr.tidy %>% 
  filter(is.na(plant_id_number)) %>% 
  select(sheet,  yr, plant_id_number) %>% 
  tabyl(sheet) %>% 
  gt() %>% 
  tab_header(title = "No plant id for these records in the orignal data")

## based on above, will try another stid with spp
offt.raw.spr.tidy <- offt.raw.spr.tidy %>% 
  mutate(stid.alt = paste0(site_id,"-",microplot_location,"-", species_code))

```


#### Tally u and b

```{r}
# test
# offt.cln.spr.tidy %>% 
#   pivot_wider(names_from = browsed_or_unbrowsed, values_from = )
```


```{r}

### new object
offt.cln <- offt.raw.spr.tidy %>% 
  group_by(stid, yr, browsed_or_unbrowsed) %>% 
  mutate(stem.tally = n()) %>% 
  ungroup()

## replacing NA for 'additioal shoot' with 0 as this seems implied
offt.cln <- offt.cln %>% 
  mutate(additional_shoot = replace_na(additional_shoot, 0))

# offt.cln %>% 
#   tabyl(additional_shoot)

# offt.cln.spr.tidy %>% 
#   group_by(stid, yr, browsed_or_unbrowsed) %>% 
#   distinct(shoot_ratio) %>% 
#   ungroup()

offt.cln %>%
  names()
```

#### Multiply the stem tally by shoot ratio 


```{r}
#### Address issues with 'shoot ratio'
# !!!
# Missing shoot ratio. Making these '1'
# replacing '0' with '1'. Why? As multiplier with count, will be '0' if count is zero.
offt.cln <- offt.cln %>% 
  mutate(shoot_ratio = replace_na(shoot_ratio, 1)) %>% 
  mutate(shoot_ratio = case_when(
    shoot_ratio == 0 ~ 1,
    TRUE ~ shoot_ratio
  ))

```


```{r}
## multiply the stem tally by shoot ratio 
offt.cln <- offt.cln %>% 
  mutate(total_bu_pre_addshoot = stem.tally*shoot_ratio) %>% 
  mutate(total_bu = total_bu_pre_addshoot + additional_shoot)

```

```{r, eval = FALSE}
## !!! distinct records. 27 k to 18
offt.cln <- offt.cln %>% 
  distinct() 
```

```{r, eval= FALSE}
offt.cln %>% 
  filter(is.na(shoot_ratio)) %>% 
  datatable()

```


```{r, eval = FALSE}
###
offt.cln %>% 
  filter(!is.na(plant_id_number)) %>% 
  tabyl(site_id, yr) %>% 
  gt()
#######   need to find 2019! a little 2014 too have missing plant id

## sample
offt.cln %>% 
  sample_n(1000) %>% 
  datatable()

offt.cln %>% 
  visdat::vis_dat()
```

#### Calc total number of stems (b + u)

```{r}
## calc total number of stems (b + u)
offt.cln <- offt.cln %>% 
  group_by(stid, yr) %>% 
  mutate(tot_allstems_per_shoot = sum(total_bu)) %>% 
  ungroup()
```

#### Calc the % of shoots browsed per STEM (step 2a n Zeigenfuss 2011) 
```{r}
## calc the % of shoots browsed per STEM (step 2a n Zeigenfuss 2011)

offt.cln <- offt.cln %>% #names() 
  group_by(stid, yr) %>% 
  mutate(sum_bu_per_stem = sum(total_bu)) %>% 
  ungroup() 

offt.cln <- offt.cln %>% 
  mutate(percent_bu_per_stem = total_bu/sum_bu_per_stem*100) %>%
  mutate(percent_bu_per_stem = round(percent_bu_per_stem,1)) 

```

```{r}
## fix species code
## eliminate "DEAD" species
offt.cln <- offt.cln %>%
  filter(species_code != "DEAD") %>%
  filter(species_code != "0") %>% 
  mutate(species_code = case_when(
    species_code == "Sabe" ~ "SABE",
    species_code == "Sage" ~ "SAGE",
    species_code == "Samo" ~ "SAMO",
    species_code == "SA-" ~ "SAXX",
    TRUE ~ species_code
  ))

```


```{r}
### summary plots
offt.percbrowsed <- offt.cln %>% 
  filter(browsed_or_unbrowsed == "B") %>% 
  select(c(yr, site_type, site_id, species_code, sum_bu_per_stem, percent_bu_per_stem))

offt.percbrowsed %>% 
  distinct(species_code)

```

```{r}
offt.percbrowsed %>%
  ggplot(aes(x = as_factor(yr), y = percent_bu_per_stem)) +
  geom_boxplot(fill = "ivory2", outlier.shape = NA) +
  labs(x = "Year",y = "% leader use") +
  facet_wrap(~site_type) +
  theme_minimal()

offt.percbrowsed %>% 
  ggplot(aes(x = percent_bu_per_stem, y = as_factor(yr))) +
  geom_density_ridges(rel_min_height = 0.005,panel_scaling = TRUE) +
  scale_y_discrete(expand = c(0.01, 0)) +
  scale_x_continuous(expand = c(0.01, 0)) +
  theme_minimal() +
  labs(x = "% leader use", y = "", caption = "all species") +
  facet_wrap(~site_type) 
ggsave("./output/figures_exported/ggridge_percleaderuse_site_type_20200602.png", width = 8.5, height = 6, dpi = 300)

offt.percbrowsed %>%
  filter(site_type != "WK") %>% 
  ggplot(aes(y = percent_bu_per_stem)) +
  geom_histogram() +
  # theme_minimal() +
  theme_bw() +
  labs(y = "% leader use", x = "count", caption = "all species") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  # facet_grid(as_factor(yr) ~site_type)
  facet_grid(site_type ~ as_factor(yr))
  # facet_wrap(~site_type, scales = "free_x") 
ggsave("./output/figures_exported/histo_percleaderuse_wc_wnc_20200602.png", width = 9.5, height = 4.5, dpi = 300)

offt.percbrowsed %>% 
  ggplot(aes(x = percent_bu_per_stem)) +
  # geom_histogram() +
  geom_density(aes(color = as_factor(yr))) +
  facet_wrap(~site_type) +
  theme_minimal() +
  labs(x = "% leader use", y = "")

# WC density  
offt.percbrowsed %>% 
  filter(site_type == "WC") %>%
  ggplot(aes(x = percent_bu_per_stem)) +
  # geom_histogram() +
  geom_density(aes(color = as_factor(yr))) +
  facet_wrap(~site_type) +
  theme_minimal() +
  labs(x = "% leader use", y = "", color = "")
ggsave("./output/figures_exported/desnity_percleaderuse_wc_20200602.png", width = 4.5, height = 3.75, dpi = 300)

# WNC density  
offt.percbrowsed %>% 
  filter(site_type == "WNC") %>%
  ggplot(aes(x = percent_bu_per_stem)) +
  # geom_histogram() +
  geom_density(aes(color = as_factor(yr))) +
  facet_wrap(~site_type) +
  theme_minimal() +
  labs(x = "% leader use", y = "", color = "")
# ggsave("./output/figures_exported/desnity_percleaderuse_wnc_20200602.png", width = 4.5, height = 3.75, dpi = 300)
```

```{r}
### summary by site
offt.percbrowsed.summary <- offt.percbrowsed %>% 
  group_by(yr, site_type) %>% 
  summarytools::descr(var = percent_bu_per_stem, round.digits = 1) %>% 
  summarytools::tb()

offt.percbrowsed.summary %>% 
  gt() %>% 
  tab_header(title = "Willow Offtake (% leader use)") %>% 
  fmt_number(
    columns = 4:18,
    decimals = 1,
    suffixing = TRUE
  )

```

```{r}

offt.percbrowsed.summary %>%
  ggplot(aes(yr, med)) +
  geom_col(fill = 'ivory3') +
  geom_errorbar(aes(ymin = med - mad, ymax = med + mad)) +
  facet_wrap(~site_type) +
  theme_minimal()

```

### summary by site and species

```{r}
offt.percbrowsed.summary <- offt.percbrowsed %>% 
  group_by(yr, site_type) %>% 
  summarytools::descr(var = percent_bu_per_stem, round.digits = 1) %>% 
  summarytools::tb()

offt.percbrowsed.summary %>% 
  gt() %>% 
  tab_header(title = "Willow Offtake (% leader use)") %>% 
  fmt_number(
    columns = 4:18,
    decimals = 1,
    suffixing = TRUE
  )

```

### Calculate DD1, the avg proportion of shoot consumed per stem (step 3 in Zeigenfuss 2011)

DD1 = (Dp - Dt)/(Db -Dt)

Dp = shoot diameter at point of browsing
Dt = Avg diam of of unbrowsed stems
Db = diamter at base of shoot

```{r, eval=FALSE}
offt.cln %>% 
  names()
  # visdat::vis_dat()

## Calculate: 
## Dp = shoot diameter at point of browsing &
## Db = diamter at base of shoot
offt.cln <- offt.cln %>%
  mutate(Db = dia_base_of_shoot_mm) %>% 
  mutate(Dp = dia_tip_of_shoot_mm)

## calculate Dt - Avg diam of of unbrowsed stems  
Dt.table <- offt.cln %>% 
  filter(browsed_or_unbrowsed == "U") %>% 
  group_by(stid, yr) %>% 
  summarise(Dt = mean(Dp, na.rm = TRUE)) %>% 
  

## Dtsite
Dtsite.table <- offt.cln %>% 
  filter(browsed_or_unbrowsed == "U") %>% 
  group_by(site_id, species_code, yr) %>% 
  summarise(Dtsite = mean(Dp, na.rm = TRUE))

## Dtspecies
Dtspp.table <- offt.cln %>% 
  filter(browsed_or_unbrowsed == "U") %>% 
  group_by(species_code, yr) %>% 
  summarise(Dtspp = mean(Dp, na.rm = TRUE)) %>% 
  mutate(Dtspp = case_when(
    species_code == "SALA" ~ 0.748, # setting to Dt of SAXX, since there are NaN for SALA and SAWO
    species_code == "SAWO" ~ 0.748,
    TRUE ~ Dtspp
  ))

## join in the Dt values
offt.cln.br <- offt.cln %>% 
  filter(browsed_or_unbrowsed == "B") %>% 
  left_join(.,Dt.table)

## join Dtsite for BROWSED
offt.cln.br <- offt.cln %>% 
  filter(browsed_or_unbrowsed == "B") %>%
  left_join(.,Dtsite.table)

## join in Dtspp for BROWSED
offt.cln.br <- offt.cln %>% 
  filter(browsed_or_unbrowsed == "B") %>%
  left_join(.,Dtspp.table)

offt.cln.br %>%
  visdat::vis_dat(warn_large_data = FALSE)

## IF Dt is NA after sub in Dtsite (if available. Will still be Na, but fewer)
offt.cln.br <- offt.cln.br %>%
  mutate(Dtadj = case_when(
    is.na(Dt) ~ Dtsite,
    TRUE ~ Dt
    )
  )
## IF Dt is still NA after subbing in Dtsite, replace with Dtspp
offt.cln.br <- offt.cln.br %>%
  mutate(Dtadj = case_when(
    is.na(Dtadj) ~ Dtspp,
    TRUE ~ Dtadj
    )
  )

## if Dt is negative or greater than zero (part 3 in Zeigenfuss 2011). Where Dt is < Dtspp, replace with Dtspp
offt.cln.br <- offt.cln.br %>%
  mutate(Dtadj = case_when(
    Dt <= Dtspp ~ Dtspp,
    TRUE ~ Dtadj
    )
  )

## covert values >1 to 1 (can't have more than 100%) -- see Zeigenfuss
offt.cln.br <- offt.cln.br %>%
  mutate(Dtadj = case_when(
    Dtadj > 1 ~ 1,
    TRUE ~ Dtadj
    )
  )

# offt.cln.br %>% 
#   summarytools::descr(Dtadj) %>% 
#   summarytools::tb()


```

# DD1stem >>>
```{r}
### calc DD1
offt.cln.br %>% names()
offt.cln.br <- offt.cln.br %>%
  group_by(stid, yr) %>% 
  mutate(DD1 = ((Dp - Dtadj)/(Db - Dtadj))) %>% 
  ungroup()

offt.cln.br %>% 
  View()

offt.cln.br %>% 
  filter(!is.na(DD1)) %>% 
  summarytools::descr(DD1,na.rm = TRUE)

```

# ^^^^
```{r, eval = FALSE}
## Notes for above from Ziegenfuus 2011
## There are some cases where no unbrowsed shoots were measured on an individual stem and thus an average unbrowsed tip diameter (Dt) for the stem cannot be calculated. In this case, an average unbrowsed tip diameter for all the stems of a particular species within a site is calculated (Dtsite) and then substituted for Dt. If there were no unbrowsed shoots of a species found within an individual site, then an average unbrowsed shoot tip can be calculated from all shoot measurements of that species (Dtsp) that were collected from other willow-monitoring sites measured within the same year and this average is substituted for Dt.

```

### calc the % of shoots browsed per SITE (step 2b n Zeigenfuss 2011)

```{r}
## calc the % of shoots per site and year (step 2b in Z 2011)
offt.cln.site.allwillow <- offt.cln %>%
  group_by(site_id, species_code)
  


## calc the proporation of browsed/unbrowsed stems out of total
offt.cln <- offt.cln %>% 
  mutate(perc_bu_shoots = total_bu/tot_allstems*100)

browsed_percent <- a.stid.cnt.bu %>% 
  filter(browsed_or_unbrowsed == "B") %>% 
  dplyr::select(stid, yr, species_code, browsed_or_unbrowsed, perc_bu_shoots)

browsed_percent %>% 
  filter(!is.na(perc_bu_shoots)) %>% 
  distinct() %>% 
  View()

offt.cln.spr.tidy <- offt.cln.spr.tidy %>%   
  filter(is.na(shoot_ratio))
  tabyl(shoot_ratio)
```


```{r}
## try some cleaning
offt.cln.spr.tidy <- offt.raw.spr.tidy %>% 
  filter(!is.na(dia_tip_of_shoot_mm))   
  
  
# offt.raw.spr.tidy %>% 
#   vtree::vtree(.,"species_code yr", palette = 9)
  # vtree::vtree(.,"yr site_type", pattern = TRUE, palette = 9)
```


```{r}
offt.raw.spr.tidy %>% 
  names()
    
##### define function
# dd2 = function(df){
#   b = df$number_browsed_cag_stems
#   u = df$number_unbrowsed_cag_stems
#   Dp = df$
# } 


```


# >
```{r}
# 'number_browsed_cag_shoots','number_unbrowsed_cag_shoots', 'dia_base_of_shoot_mm','dia_tip_of_shoot_mm','shoot_length_cm','total_stem_count'
```


```{r, eval = FALSE, echo=FALSE}
###### Get the names of the macroplot tabs as vector with datapasta
wo.d %>% 
  names() %>% 
  as.tibble() %>% 
  filter(str_detect(value, 'Macroplot')) # copy from clipboard and paste as vector

### Extract out just the macroplot tabs
mp.list <- purrr::map(c("z2008-09 Macroplot Baseline",
  "z2013 Macroplot Inventory",
  "z2015 Macroplot Inventory",
  "z2016 Macroplot Inventory",
  "z2017 Macroplot Inventory",
  "z2018 Macroplot Inventory"),
  ~ wo.d[.]) 

# get the names of df. Note use of the 'at_depth' argument to dial into the second level of the list
df.names <- mp.list %>% 
  at_depth(2, names) %>% 
  at_depth(2, tibble)

# df.names %>% 
#   at_depth(2,walk(.,View)) # this sort of works, but b/c of the nested lists, not useful

###### UNLIST!!!!! #####
new.pp <- unlist(df.names,recursive=FALSE)

# walk(new.pp,View) # this works! Opens a View portal for each list item 
# walk(new.pp,print) # prints each list item to console
# the takehome is there are different number of columns in each tab!
# can't combine

df.names %>% 
  at_depth(2,map_df(.,rbind))



##################
# purrr::map(c(#"2008-09 Macroplot Baseline",
#   "2013 Macroplot Inventory",
#   "2015 Macroplot Inventory",
#   "2016 Macroplot Inventory",
#   "2017 Macroplot Inventory",
#   "2018 Macroplot Inventory"),
#   ~ wo.d[.]) 

```



```{r, eval=FALSE}
# Create a cache of workbook tabs as CSV files
## cache csv. This creates a csv cache of each tab in the workbook. 

read_then_csv <- function(sheet, path) {
  pathbase <- path %>%
    basename() %>%
    tools::file_path_sans_ext()
  path %>%
    read_excel(sheet = sheet) %>% 
    write_csv(paste0(pathbase, "-", sheet, ".csv"))
}

path %>%
  excel_sheets() %>%
  set_names() %>% 
  map(read_then_csv, path = path)

map_df(.x = mp.list,.f = bind_rows)

mp.list2 <- mp.list %>% 
  map_if(is.numeric, as.character) 

bind_rows(mp.list, .id = "id")


za <- path %>%
  excel_sheets() %>%
  set_names() %>% 
  map_df(~ read_excel(path = path, sheet = .x), .id = "sheet")

path %>%
  excel_sheets() %>%
  set_names() %>% 
  map_df(~ read_excel(path = path, sheet = .x, range = "A2:F15"), .id = "sheet")

######
name.lineInt <- wo.d 
# %>% 
  # names() %>% 
  # as.tibble() %>% 
  # filter(str_detect(value, 'Line'))

wo.d %>%
  names() %>%
  as.tibble() %>%
  filter(str_detect(value, 'Site')) 
######

### Extract out just the line intercept
bl.list <- purrr::map(c("2008-09 Line Intercept Baseline",
  "2013 Line Intercept",
  "2015 Line Intercept",
  "2016 Line Intercept",
  "2017 Line Intercept",
  "2018 Line Intercept"),
  ~ name.lineInt[.]) 


# #### Example: extract subset
# library(purrr)
# library(magrittr)
#> 
#> Attaching package: 'magrittr'
#> The following object is masked from 'package:purrr':
#> 
# #>     set_names
# l <- list(a = "foo", b = "bar", c = "baz")
# 
# purrr::map(c("a", "b"), ~ l[.]) %>% unlist()
# ####


# library(readxl)    
# read_excel_allsheets <- function(filename) {
#     sheets <- readxl::excel_sheets(filename)
#     x <-    lapply(sheets, function(X) readxl::read_excel(filename, sheet = X))
#     names(x) <- sheets
#     x
# }
# 
# mysheets <- read_excel_allsheets("data/EVMP_20181010/TenYearReview/Willow_Cumulative_Data_Baseline_Through_2018.xlsx")


b2007 <- readxl::read_excel("data/EVMP_20181010/TenYearReview/Upland_Line_Intercept_2007_2013_2018.xlsx",sheet = 2) %>% 
  mutate(yr = 2007)

b2013 <- readxl::read_excel("data/EVMP_20181010/TenYearReview/Upland_Line_Intercept_2007_2013_2018.xlsx",sheet = 3) %>% 
  mutate(yr = 2013)


b2018 <- readxl::read_excel("data/EVMP_20181010/TenYearReview/Upland_Line_Intercept_2007_2013_2018.xlsx",sheet = 4) %>% 
  mutate(yr = 2018) %>% 
  mutate(SHRUB_HEIGHT_CM = as.character(SHRUB_HEIGHT_CM))

# combine 07 and 13
baseline <- bind_rows(b2007,b2013) 

## bring in the 2018
baseline <- baseline %>% 
  bind_rows(., b2018)

# View(baseline)


```

```{r, echo=FALSE}

# Rewrite the SAS program used to analyze willow height data as found in table 9 of Zeigenfuss and Johnson (2015)--Least squares means of average and maximum willow height and percent willow cover on burned sites compared to unburned sites using the macroplot method at EVMP willow monitoring sites in Rocky Mountain National Park, Colorado. 
# 
# **Steps:** 
# 
# 1. Read in data from a file containing the baseline data from willow macroplots  
# 2. Calculate canopy area for each plot and assigns the baseline year (2008) to these data 
# 3. Sort data down to willow and non-willow species groups and calculates mean for the variables "average height" and "maximum ht" for each group.
# 
# 
# 
# [follow up]
# **See: **  
# 
# >willow shrub cover macro table 8.sas  
# >willow shrub height table 8.sas  
# >willow shrub cover macro table 9.txt    
# >willow shrub height table 9.txt 

```
 





```{r}
asp1 <- read_excel("data/EVMP_data/TenYearReview/Aspen_Data_Baseline_through_2018.xlsx")
# View(Aspen_Data_Baseline_through_2018)

```


```{r, echo = FALSE}
# Percent of aspen monitoring sites on elk winter range and Kawuneeche Valley of Rocky Mountain National Park, Colorado, that had a recruiting sapling cohort (at least 400 stems per hectare of height between 1.5 and 2.5 meters) at baseline sampling and in 2013. Entire winter range numbers are weighted by the percent area in each location.
# 
# Tally of Live Aspen Stems per Plot >2.5 m in Height (DBH=diameter at breast height [1.4 m])		
# 
# Tally of Live Aspen Stems per Plot <2.5 m in Height				
# 
# 
# Tally of Dead Aspen Stems per Plot >2.5 m in Height (DBH=diameter at breast height [1.4 m])
# 
# Cleaned data to make readable as csv
# 
# Site Type: AC=core, ANC=non-core, AK=Kawuneeche Valley
```




```{r, echo=FALSE}

# Rewrite the SAS program used to create figs. 3,4,5, and 7 of Zeigenfuss and Johnson (2015)--Distribution of aspen tree (height greater than 2.5 meters) stem diameters in monitoring sites. 
# 
# **Steps:** 
# 1. Read in data from a file with tallies of live aspen stems by dbh size class  
# 2. Read in a file with information for each aspen monitoring site  
# 3. Merge these two files, remove saplings 
# 4. Reclass trees into groups of small (2-10 cm dbh), medium (10-20 cm dbh) and large (20+ dbh) trees.
# 
# 
# **See: **  
# 
# >aspen sapling table 4.sas  
# >aspen sapling table 5.sas 
```


#### Offtake comparisons and relation management goals



```{r}

```



## Upland

**Data import** 

```{r, eval=TRUE}

uli <- readxl::excel_sheets("data/EVMP_data/TenYearReview/Upland_Line_Intercept_2007_2013_2018.xlsx")
# uli

b2007 <- readxl::read_excel("data/EVMP_data/TenYearReview/Upland_Line_Intercept_2007_2013_2018.xlsx",sheet = 2) %>% 
  mutate(yr = 2007)

b2013 <- readxl::read_excel("data/EVMP_data/TenYearReview/Upland_Line_Intercept_2007_2013_2018.xlsx",sheet = 3) %>% 
  mutate(yr = 2013)


b2018 <- readxl::read_excel("data/EVMP_data/TenYearReview/Upland_Line_Intercept_2007_2013_2018.xlsx",sheet = 4) %>% 
  mutate(yr = 2018) %>% 
  mutate(SHRUB_HEIGHT_CM = as.character(SHRUB_HEIGHT_CM))

# combine 07 and 13
baseline <- bind_rows(b2007,b2013) 

## bring in the 2018
baseline <- baseline %>% 
  bind_rows(., b2018)

# View(baseline)

# janitor::excel_numeric_to_date()

######### DEAL WITH NA #############
na_strings <- c("NA", "N A", "N / A", "N/A", "N/ A", "Not Available", "NOt available")

baseline <- baseline %>%
  naniar::replace_with_na_all(condition = ~.x %in% na_strings) %>%
  mutate(DATE = as.numeric(DATE)) 


```



```{r, eval=FALSE}
bl.sel <- baseline %>%
  select(
  ELEVATION_M,
  starts_with("UTM"),
  DATE,
  SITE_ID,
  SITE_NUMBER,
  SITE_TYPE,
  SHRUB_SPECIES,
  SHRUB_HEIGHT_CM,
  yr
  ) 

####

bl.sel %>% 
  na.omit() 

```


```{r, echo=FALSE}
# Discussion

# Targets from Ziegenfuss and Johnson 2015:
# 
# 1.Progressive increase in aspen regeneration above the baseline level of 13 percent to at least 45 percent of winter range stands (presence of stems less than 2 cm dbh reaching 1.5–2.5 m tall).
```

## Wild basin

```{r}

```

### Comparison plot: willow height by valley, with wild basin

Wild Basin willow data survey 2018.csv

```{r}
wbasin <- read_csv("./data/wild_basin/Wild Basin willow data survey 2018.csv")

wbasin <- wbasin %>%
  janitor::clean_names()
  
wbasin.sel <- wbasin %>% 
  rename(plant_ht_cm = max_ht_cm) %>% 
  mutate(yr = 2018) %>% 
  mutate(fenced = "N") %>% 
  mutate(site_type = "WB") %>% 
  mutate(site_id = paste0("WB",point)) %>% 
  dplyr::select(c(yr, site_type, site_id, plant_ht_cm, species, fenced, location)) %>% 
  distinct()
  

```


```{r}
# exp lu
csv.all.lc.mcro.df.cln <- csv.all.lc.mcro.df %>% 
  clean_names()

  
willow.mcro.evmp <- csv.all.lc.mcro.df.cln %>%
  rename(species = species_code) %>% 
  dplyr::select(yr, site_type, species, site_id, plant_ht_cm, fenced, location) %>% 
  distinct()


willow.mcro.evmp18 <- willow.mcro.evmp %>% 
  filter(yr == 2018)

#### bind wb with 2018 evmp
wb.evmp18 <- bind_rows(wbasin.sel, willow.mcro.evmp18) %>% 
  distinct()

```

## Willow height comparison amonng WBasin and EVMP
```{r}
## compare WILLOW height

wb.evmp18 %>%
  filter(str_detect(species, "^S")) %>% 
  ggplot() +
  geom_density(aes(fill = site_type, color = site_type, lty = site_type, x = plant_ht_cm), alpha = 0.05) +
  theme_minimal() +
  labs(x = "Willow height (cm)", y  = "Density", lty= "Site type", color = "Site type", fill = "Site type", caption = "willow height, WB + EVMP, Salix only")

# ggsave("./output/figures_exported/WB_EVMP_willow_height.png", dpi = 300, width = 4.75, height = 3.75)
```

```{r}
wb.evmp18.willows <- wb.evmp18 %>%
  filter(str_detect(species, "^S"))

gt.wbevmp.tbl <- wb.evmp18.willows %>% 
  select(-yr) %>% 
  group_by(site_type) %>% 
  summarytools::descr() %>% 
  summarytools::tb() %>% 
  select(-c(variable, se.skewness, kurtosis, pct.valid)) %>% 
  gt()
  
gt.wbevmp.tbl <- gt.wbevmp.tbl %>% 
  tab_header(title = "Willow Height (cm)") %>% 
  fmt_number(
    columns = 2:12,
    decimals = 1,
    suffixing = TRUE
  ) 

## save
# gt.wbevmp.tbl %>% 
#   gt::gtsave(filename = "./output/tables/WB_vs_EVMP_willowHt.rtf")
# 

```



# Covariates: Elk
```{r}
elk <- read_csv("./data/covariates/elk/RMNP_elk_pop_summary_cln.csv")

```




# References  

Johnson, T. L., L. C. Zeigenfuss, N. Thompson, and J. A. Mack. 2016. The role of science through a century of elk and habitat management at Rocky Mountain National Park. Park Science 32(2):70–72

U.S. Department of the Interior, 2007, Elk and vegetation management plan, Rocky Mountain National Park, Colorado: Washington D.C., National Park Service, unpaged, accessed online May 6, 2013 at http://www.nps.gov/romo/parkmgmt/elkveg_mgmt_plan_feis.htm.

U.S. Department of the Interior, 2008, Record of decision, Final environmental impact statement, Elk and vegetation management plan, Rocky Mountain National Park, Colorado: Washington D.C., National Park Service, 21 p., accessed online May 6, 2013 at www.nps.gov/romo/parkmgmt/upload/rod_evmp_signed_2-15-08.pdf.

Zeigenfuss, L., Johnson, T., and Wiebe, Z., 2011, Monitoring plan for vegetation responses to elk management in Rocky Mountain National Park: U.S. Geological Survey Open-File Report 2011–1013, 85 p.

Zeigenfuss, L.C., and T.L. Johnson, 2015, Monitoring of vegetation response to elk population and habitat management in Rocky Mountain National Park, 2008–14: U.S. Geological Survey Open-File Report 2015–1216, 44 p., http://dx.doi.org/10.3133/ofr20151216.

# Appendix 1. Data notes from E. Ertl

The following are notes from E. Ertl recorded in an describing EVMP vegetation data collection, as recorded in 2018.  

#### Aspen

* Plots lost: AC41 (plot was washed away in the 2013 flood)

* Plots added: AC68 to replace AC41

* Plots that had been treated with fuels management work that has not been noted before: ANC5, ANC7, ANC8, ANC19 (I think?) these areas were thinned of most large trees opening up the canopy substantially and the area was also pile burned; none of the plots appeared to be directly in the pile burn scars but a few came very close; these treatments could alter data in the future (working on getting a GIS layer for this)

* Formatted 2015 – 2018 data. 2015-2017 data only consisted of burn plot sampling; no burn plot data collected in 2014

#### Upland

* Plots lost: UC09 (this plot was most likely lost in the 2013 flood), UC14 & UC24 (plots were lost to waterline construction that occurred from 2015-2018)

* Plots added: UC37, UC38, UC39 to replace the three plots that were lost

* Plots have been treated by prescribed fire in the past; Prescribed fire occurred from 9/17 – 10/2 of 2008; First round of data collected for upland sites occurred in 2007 (working on getting recent GIS layers to account for any other treatments)

* Prescribed burning is planned for this coming October 2018 as well, which will potentially burn several upland plots in the Beaver Meadows area

* Formatted 2018 shrub data

#### Willow

* Plots lost: WK03; this plot hasn’t been found since 2012 and we looked several times in 2018

* Plots added: WK09 to replace WK03 (updated measurement schedule in the protocol), WK10 added late season after talking with Linda Z. – she suggested there be 4 fenced plots in the KV to make the data collected from this area more robust. We weren’t aware of this when we installed WK09, so there will be nine total west side plots (4 fenced and 5 unfenced).

* Removed the microplot stem counts from the macroplot sampling in the protocol per Linda Z. early summer

* Formatted 2015 – 2018 cumulative willow data
	2015-2017 data only consisted of burn plot sampling; there is no burn data for 2014
	In 2015 it appears they were only measuring willow in the macroplots, not all shrubs like they should have been.

* Fixed unit and rounding issues in data.	In 2016 the crew measured additional burned sites that are not on the burn survey list (WC32, WC34, WC78, WC84, and WC85). For some plots they only measured willow instead of measuring all shrubs. Fixed unit and rounding issues in data.

* There is only west side data for 2016 and 2017; Nick B. said they weren’t aware that west side plots were supposed to be measured every year back in 2014/2015. Burn survey and west side data are currently combined by year measured

* Formatted 2015 – 2018 offtake data (2014 was already added and analyzed in the 2013 review)
	2015 offtake notes: Crew didn’t sample WC9, WC78, WC79 (plots are in fences) and sampled extra plots that are not on the protocol list for offtake including WC34, WC35, WC52, WC54, WC56, WK6, WK7, and WK8 (none of these are in fences)

* 2016 offtake notes: Crew didn’t sample WC79 (fenced), WC85 (fenced), WK3 (lost), WNC30 (couldn’t find plot) and sampled extra plots that are not on the protocol list for offtake including WC34, WC35, WC37 (fenced), WC50 (fenced), WC57, WC69, WC70, WC71, WC76 (fenced), WC81, WC82, WC83, WC86 (fenced)

*	2017 offtake notes: Crew didn’t sample WC76 (fenced), WC85 (fenced), WNC30 (couldn’t find plot), WK3 (lost), WK6 (river probably too high to access) and no extra plots were sampled

*	2018 offtake notes: Crew didn’t sample WC33 (removed 2014), WC76 (fenced), WC77 (fenced), WK3 (lost and removed from list in 2018, replaced with WK9 at end of season), WK6 (river too high to access plot)  
* There were discrepancies between the protocol and the willow master database on what sites to sample for offtake (added by C. Piper). Linda and I updated this schedule in the protocol for future years because the old schedule included plots that were no longer there and plots that have since been fenced.

* Burn Surveys 2015-2019 – spoke with Linda Z. and she doesn’t think these need to be measured again in 2019 unless the data is showing something interesting.

* Willow stake restoration sites – have these been cross referenced with willow monitoring sites? Were willow stakes planted in some plots? I did find notes that there were willow stakes being measured in WC76 over the years, which would need to be analyzed separately I’m assuming.

#### Other notes

* Kept all of Linda’s original data for the last 5-year review under EVMP’s “analysis” folder

* Created new (2018) versions of data for 10-year review analysis but did not delete out any data from previous years where plots were lost this year; also kept old components in the data (i.e. willow shoot measurements, microplot stem counts)

* All formatted data for 2018 can be found under EVMPVegetationAnalysis10 Year Review

* Blank datasheets have been updated for 2018

* Protocols are currently being updated for 2018 and master databases have been updated for 2018. 

* Added a “Fuels Treatment Post Establishment” and “Treatment Year” column that could be queried by type (i.e. prescribed fire, mechanical treatments, etc.) 

* Created new shapefiles for all veg plots; trying to find shapefiles for treatment areas in the park and will put them in the EVMP_Veg_Data_2018 geodatabase
	Located under EVMPVegetationGISEVMP_Veg_Data_2018.gdb OR ShapefilesMaster_Veg_Sites_Shp2018

* Created new veg maps. Located under EVMPVegetationLogisticsMapsEVMP vegetation plot maps2018 Veg Site MapsPlot Maps

* Wild Basin Willow Data – I created a folder with all of the data collected at Wild Basin this fall. It is located under EVMPVegetationAnnual RecordsFY18Wild Basin – Willow Data
* Uploaded all 4 iPads with new electronic datasheets for willow and upland, photo points and plot diagrams from 2018, willow ID keys, updated protocol from 2018, and new vegetation site maps.

-----



